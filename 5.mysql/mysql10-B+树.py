import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="mysql"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("B+树")
r2=s2.getRootTopic()
r2.setTitle("B+树")


content={
'二叉树':[
    '1.非叶子节点最多拥有两个子节点',
    '2.非叶子节值大于左边子节点、小于右边子节点'
],
'平衡二叉树':[
    '1.树的左右两边的层级数相差不会大于1',
    '2.没有值相等重复的节点',
    {'实现算法':[
        '红黑树的变色与旋转'
    ]}
],
'B树':[
    'B-树，Balance Tree,平衡多叉树',
    {'一个m阶的B树特征':[
        '根结点至少有两个子女',
        '每个中间节点都包含k-1个元素和k个孩子，其中 m/2 <= k <= m',
        '每一个叶子节点都包含k-1个元素，其中 m/2 <= k <= m',
        '所有的叶子结点都位于同一层',
        '每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划'
    ]},
    '应用：文件索引及部分数据库索引（MongoDB）',
    '范围查找：中序遍历'
],
'B+树':[
    {'特征':[
        '1.根节点：只保存索引',
        '2.中间节点：只保存索引,索引值同时存在于子节点，是子节点元素中是最大（或最小）元素',
        '3.叶子节点：保存索引与数据，按键值的大小顺序存放，并通过指针进行连接',
        '4.查找：从上到下查找'
    ]},
    {'优势':[
        '1.非叶子节点存储更多的元素，同样数据量时，树更矮，查询的IO次数更少',
        {'更适合磁盘存储与读取':[
            'N=1200,树高4,存1200的3次方,17 亿',
            '树根放内存，查值最多访问3次磁盘',
            '配合磁盘特性，减少单次查询的磁盘访问数'
        ]},
        '2.所有查询都要查找到叶子节点，查询性能稳定',
        '3.叶子节点形成有序链表，便于范围查询',
    ]},
    {'插入':[
        '当前结点key<=m-1，插入结束',
        '否则叶子结点分裂，左叶子结点含前m/2个记录，右结点含剩下的，第m/2+1个记录的key进位到父结点中'
    ]},
    {'删除':[
        '结点的key>=Math.ceil(m/2)–1，删除结束',
        '否则若兄弟结点有富余，父结点key下移，兄弟结点key上移',
        '或当前结点和兄弟结点及父结点下移key合并成一个新的结点'
    ]}
],
'B树和B+树的区别':[
    {'B树':[
        '每个节点都存储key和data，所有节点组成这棵树',
        '叶子节点指针为null，叶子结点不包含任何关键字信息'
    ]},
    {'B+树':[
        '叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针',
        '叶子结点本身依关键字的大小自小而大的顺序链接',
        '非叶子结点可看成索引部分，结点中仅含有其子树根结点中最大（或最小）关键字'
    ]}
]
}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 