import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="thread"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("lock_base")
r2=s2.getRootTopic()
r2.setTitle("锁基础")


content={
'乐观锁/悲观锁':[
    '线程要不要锁住同步资源',
    '悲观锁:适写操作多场景,在Java中使用，是利用各种锁',
    '乐观锁,适读操作多场景,在Java中使用，是无锁编程，常用CAS算法'
],
'伪共享':[
    '缓存系统中是以缓存行(cache line)为单位存储的',
    '当多线程修改互相独立的变量时,如果这些变量共享同一个缓存行',
    '就会无意中影响彼此的性能(番发送RFO消息，占得缓存行的拥有权)',
    {'避免':[
        '缓存填充：让不同线程操作的对象处于不同的缓存行',
        '使用编译指示，强制使每一个变量对齐'
    ]}
],
'偏向锁/轻量级锁/重量级锁':[
    '通过对象监视器在对象头中的字段来表明的',
    '无锁->偏向锁->轻量级锁->重量级锁,锁状态只能升级不能降级',
    {'偏向锁':[
        '一段同步代码一直被一个线程访问，线程会自动获取锁',
        '目标:在只有一个线程执行同步代码块时提高性能',
        '当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID',
        '线程进入和退出同步块时不再通过CAS操作来加锁和解锁',
        '而是检测Mark Word里是否存储着指向当前线程的偏向锁',
        '只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁'
    ]},
    {'轻量级锁':[
        '当锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁',
        '其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能',
        {'过程':[
            '代码进入同步块，如同步对象锁为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”）',
            '虚拟机将在当前线程的栈帧中建立名为锁记录（Lock Record）的空间，存储锁对象Mark Word的拷贝',
            '拷贝成功，虚拟机使用CAS尝试将对象的Mark Word更新为指向Lock Record的指针',
            '并将Lock Record里的owner指针指向对象的Mark Word',
            '如更新成功，线程拥有该对象的锁，对象Mark Word的锁标志位设置为“00”，对象处于轻量级锁定',
            '如轻量级锁更新失败，虚拟机会检查对象的Mark Word是否指向当前线程的栈帧',
            '如是说明当前线程已拥有这个对象的锁，可以直接进入同步块继续执行，否则说明多个线程竞争锁'
        ]}
    ]},
    {'重量级锁':[
        '当锁为轻量级锁时，另一个线程自旋，但不会一直自旋->',
        '自旋一定次数还没有获取到锁，进入阻塞->',
        '该锁膨胀为重量级锁,锁标志的状态值变为“10”',
        'Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态,性能降低'
    ]},
    {'综上':[
        '偏向锁:通过对比Mark Word解决加锁问题，避免执行CAS操作',
        '轻量级锁:是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能',
        '重量级锁:是将除了拥有锁的线程以外的线程都阻塞'
    ]}
],
'自旋锁VS适应性自旋锁 ':[
    {'自旋锁':[
        {'适用':[
            '线程挂起和恢复现场的时长>用户代码执行时长'
        ]},
        {'评价':[
            '避免线程切换开销',
            '但占用处理器时间',
            '使用CPU时间换取线程阻塞与调度的开销'
        ]},
        '自旋等待时间要有限度，没有成功获得锁，应当挂起线程',
        'do-while循环就是一个自旋操作',
        {'三种常见的锁形式':[
            'TicketLock',
            'CLHlock',
            'MCSlock'
        ]}
    ]},
    {'适应性自旋锁':[
        '自旋时间或次数不固定:由前一次在同一个锁上的自旋时间及锁拥有者的状态决定',
        {'情况1':[
            '如在同一个锁对象上',
            '自旋等待刚成功获得过锁，并且持有锁的线程正在运行中',
            '虚拟机认为这次自旋很有可能成功',
            '进而允许自旋等待更长时间'
        ]},
        {'情况2':[
            '如某个锁自旋很少成功获得过',
            '以后尝试获取这个锁将省略自旋',
            '直接阻塞线程，避免浪费处理器资源'
        ]}

    ]}
],
'公平锁VS非公平锁':[
    '多线程竞争锁时要不要排队',
    {'公平锁':[
        '通过同步队列实现多线程按照申请锁的顺序来获取锁，实现公平特性',
        '优点:等待锁的线程不会饿死',
        '缺点:整体吞吐效率比非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大'
    ]},
    {'非公平锁':[
        '多线程直接尝试获取锁，如锁刚好可用，线程获取到锁，否则到队列的队尾等待',
        '优点:减少唤起线程的开销，整体的吞吐效率高，因线程有几率不阻塞直接获得锁',
        '缺点:处于等待队列中的线程可能会饿死，或等很久才会获得锁'
    ]}
],
'可重入锁VS非可重入锁':[
    '一个线程在多个流程能不能获得同一把锁',
    {'可重入锁':[
        'Java中ReentrantLock和synchronized',
        '优点：一定程度避免死锁',
        'AQS中维护了一个同步状态status来计数重入次数'
    ]},
    {'获取锁':[
        {'可重入锁':[
            '尝试获取并更新status值',
            '如status==0，CAS把status置为1，当前线程开始执行',
            '如status!=0，判断当前线程是否是获取到这个锁的线程，如是执行status+1'
        ]},
        '非可重入锁:直接去获取并尝试更新status，如status!=0获取锁失败，当前线程阻塞'
    ]},
    {'释放锁':[
        {'可重入锁':[
            '当前线程是持有锁的线程&&status-1==0',
            'status置为0,将锁释放'
        ]},
        '非可重入锁:当前线程是持有锁的线程,status置为0，将锁释放'
    ]}
],
'独享锁VS共享锁':[
    '多线程能不能共享一把锁',
    {'独享锁':[
        '即排他锁，该锁一次只能被一个线程持有',
        '如线程T对数据A加上排它锁后，其他线程不能再对A加任何类型的锁',
        '获得排它锁的线程即能读数据又能修改数据',
        '如JDK中的synchronized和JUC中Lock的实现类'
    ]},
    {'共享锁':[
        '锁可被多线程持有',
        '如线程T对数据A加共享锁后，其他线程也可对A再加共享锁，不能加排它锁',
        '获得共享锁的线程只能读数据，不能修改数据',
        '如ReentrantReadWriteLock'
    ]}
]


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 