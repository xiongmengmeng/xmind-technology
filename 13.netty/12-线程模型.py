import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="netty"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("线程模型")
r2=s2.getRootTopic()
r2.setTitle("线程模型")


content={

'传统阻塞IO服务模型':[
    {'特点':[
        '1.采用阻塞IO模式获取输入的数据',
        '2.每个连接都需要独立的线程完成数据的输入，业务处理，数据返回'
    ]},
    {'问题':[
        '1.当并发数据很大，会创建大量的线程，占用很大的系统资源',
        '2.连接创建后，如当前线程暂无数据可读，线程会阻塞在read操作，造成线程资源浪费'
    ]}
],
'Reactor模式':[
    '反应器模式，分发者模式，通知者模式',
    {'针对传参阻塞IO服务模型的问题，解决方案':[
        {'基于IO复用模型':[
            '多个连接共用一个阻塞对象，应用程序只需要在一个阻塞对象上等待，无需阻塞等待所有连接',
            '当某个连接有新的数据可以处理时，操作系统通知应用程序，线程从阻塞状态返回，开始进行业务处理'
        ]},
        {'基于线程池复用线程资源':[
            '不必再为每个连接创建线程，将连接完成后的业务处理任务分配给线程进行处理',
            '一个线程可处理多个连接的业务'
        ]}
    ]},
    {'基本设计思想':[
        'IO复用结合线程池',
        {'详细':[
            '1.Reactor模式，通过一个或多个输入同时传递给服务处理器的模式(基于事件驱动) ',
            '2.服务器端程序处理传入的多个请求，并将它们【同步分派】到相应的【处理线程】 ',
            '3.Reactor请求，使用IO复用监听事件，收到事件后，分发给某个线程(进程),这是网络服务器高并发处理的关键'
        ]}
    ]},
    {'核心组成':[
        {'Reactor反应器':[
            '负责查询IO事件，当检测到一个IO事件，将其发送给相应的Handler处理器去处理'
        ]},
        {'Handlers处理器':[
            '与IO事件（或者选择键）绑定，负责IO事件的处理',
            '完成真正的连接建立、通道读取、业务逻辑处理、结果写出到通道等'
        ]}
    ]},
    {'分类(根据Reactor的数量和处理资源池线程的数量)':[
        '单Reactor单线程',
        '单Reactor多线程',
        '主从Reactor多线程'
    ]},
    {'netty线程模型':[
        '基于主从Reactor多线程做了一定的改进'
    ]},
    {'应用':[
        '“全宇宙最有名的、最高性能”的Web服务器Nginx',
        '最高性能的缓存服务器之一Redis',
        '开源项目中应用极为广泛的高性能通信中间件Netty'
    ]},
    {'优点':[
        {'响应快':[
            '虽然同一反应器线程本身是同步的，但不会被单个连接的同步IO所阻塞'
        ]},
        {'编程相对简单':[
            '最大程度避免复杂的多线程同步，也避免了多线程的各个进程之间切换的开销'
        ]},
        {'可扩展':[
            '可以方便地通过增加反应器线程的个数来充分利用CPU资源'
        ]}
    ]},
    {'缺点':[
        '反应器模式需要操作系统底层的【IO多路复用】的支持',
        '同一个Handler业务线程中，如出现一个长时间的数据读写，会影响这个反应器中其他通道的IO处理'
    ]},
    {'和其他模式的对比':[
        {'和生产者消费者模式对比':[
            '反应器模式是基于查询的，没有专门的队列去缓冲存储IO事件',
        ]},
        {'和观察者模式（Observer Pattern）对比':[
            '每一个IO事件（选择键）被查询后，反应器会将事件分发给所绑定的Handler处理器',
            '观察者模式中，同一个时刻，同一个主题可以被订阅过的多个观察者处理'
        ]}
    ]}
],

}


#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 