import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("字节码执行引擎")
r2=s2.getRootTopic()
r2.setTitle("字节码执行引擎")


content={
'字节码':[
    'Java【编译期】输出的指令流，是【基于栈】的【字节码指令集合】架构',
    '一种中间状态（中间码）的二进制代码（文件），需直译器转译后才能成为机器码',
    {'实现方式':[
        '编译器+虚拟机器',
        {'编译器':[
            '将源码编译成字节码'
        ]},
        {'虚拟机器':[
            '将字节码转译为可以直接执行的指令'
        ]}
    ]},
    {'设计初衷':[
        '为什么不将源代码翻译成汇编，再翻译成机器指令执行，而是翻译成字节码文件后再去翻译成汇编和机器指令',
        '满足Java程序实现【跨平台】特性,实现特定软件运行和软件环境、与硬件环境无关',
        '避免采用【静态编译】的方式直接生成【本地机器指令】',
        '->诞生了【解释器】：运行时逐行解释字节码执行程序'
    ]},
    {'编译':[
        {'编译过程':[
            '1.程序代码->词法分析->语法分析->抽象语法树',
            '2.抽象语法树->指令流（可选）->解释器->解释执行',
            '3.抽象语法树->优化器（可选）->中间代码（可选）->生成器->目标代码'
        ]},
        {'Javac编译器':[
            {'程序编译':[
                '程序代码->词法分析->语法分析->抽象语法树->遍历语法树->线性字节码指令流'
            ]},
            '上述都在Java虚拟机之外进行，而解释器在虚拟机内部，所以Java程序的编译是半独立'
        ]},
    ]}
],
'执行引擎':[
    '属于JVM的下层',
    {'作用':[
        '将【字节码指令】【解释/编译】为对应平台上的【本地机器指令】',
    ]},
    {'组成(3部分)':[
        {'解释器(Interpreter)':[
            '当Java虚拟机启动时会根据预定义的规范对字节码采用【逐行解释】的方式执行',
            '将每条字节码文件中的内容“翻译”为对应平台的【本地机器指令】执行',
        ]},
        {'及时编译器(Just In Time Compiler)':[
            '【字节码】直接【编译】成【本地机器指令】'
        ]},
        '垃圾回收器'
    ]},
    {'执行方法里字节码指令':[
        {'解释执行':[
            '通过【解释器】执行',
            '将【字节码指令】和【底层的操作系统以及硬件】对应起来',
            {'工作流程':[
                '1.依赖于PC寄存器,决定要执行的字节码指令',
                '2.执行完一项指令操作后，PC寄存器会更新下一条需被执行的指令地址',
                {'方法在执行过程中':[
                    '通过存储在【局部变量表】中的对象引用定位到Java堆中的对象实例',
                    '通过【对象头】中的【元数据指针】定位到目标对象的类型信息'
                ]}
            ]}
        ]},
        {'编译执行':[
            '通过【即时编译器】将【字节码】编译成【本地代码】执行',
            '机器可直接执行，多针对热点代码',
        ]}
    ]},
    {'基于栈和基于寄存器的指令集区别':[
        {'栈结构指令集':[
            '字节码指令流里指令大部分是零地址指令，依赖操作数栈工作'
        ]},
        '整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径',
        {'寄存器的指令集':[
            '依赖寄存器进行工作'
        ]}
    ]}

]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 