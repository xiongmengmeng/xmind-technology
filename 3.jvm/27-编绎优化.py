import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("编译器优化")
r2=s2.getRootTopic()
r2.setTitle("编译器优化")


content={
'编译器对代码优化是建立在【代码中间表示】或者是【机器码】上的，不是直接在Java源码上的':[],
'方法内联':[
    {'目的':[
        '去除方法调用的成本（如查找方法版本、建立栈帧等）',
        '为其他优化建立良好的基础'
    ]},
    {'虚方法的内联问题':[
        {'Java语言中默认的实例方法是【虚方法】':[
            'Java方法调用必须在运行时进行方法接收者的多态选择'
        ]},
        {'解决':[
            '类型继承关系分析技术'
        ]},
        {'CHA':[
            '用于确定已加载的类中',
            '接口是否有多于一种的实现',
            '某个类是否存在子类',
            '子类是否覆盖了父类的某个虚方法'
        ]},
        '单态内联缓存:比用不内联的非虚方法调用,开销多了一次类型判断',
        '多态内联缓存:开销相当于真正查找虚方法表来进行方法分派'
    ]}
],
'逃逸分析':[
    '分析对象动态作用域，对象在方法里面被定义后，是否被外部方法引用',
    {'对象逃逸程度':[
        '从不逃逸',
        {'方法逃逸':[
            '作为调用参数传递到其他方法中'
        ]},
        {'线程逃逸':[
            '被外部线程访问到，如赋值给可在其他线程访问的实例变量'
        ]}
    ]},
    {'栈上分配（Stack Allocations）':{
        '让对象在栈上分配内存，对象随着方法结束(栈帧出栈)而销毁,降低垃圾收集器的压力',
        {'适用':[
            '支持方法逃逸，不支持线程逃逸'
        ]},
    }},
    {'标量替换（Scalar Replacement）':[
        {'标量':[
            '无法再分解的数据',
            'Java中对象是典型的,由'
        ]},
        {'聚合量':[
            '多个标量组成,如java中的对象'
        ]},
        '对象拆分(使用标量来替换聚合量),为【栈上分配】提供了很好的基础',
        {'适用':[
            '对象没有逃逸出方法'
        ]},
        {'参数':[
            '-XX:+EliminateAllocations：开启了标量替换（默认打开），允许将对象打散分配在栈上'
        ]}
    ]},
    {'同步消除（Synchronization Elimination）':[
        '如一个对象被发现只有一个线程被访问到，对于这个对象的操作可不考虑同步'
    ]}
],
'公共子表达式消除':[
    '公共子表达式:表达式E之前已被计算过，先前的计算到现在E中所有变量的值都未发生变化'
],
'数组边界检查消除':[
    '把运行期检查提前到编译期'
],
'Java虚拟机编译器接口JVMCI':[
    '响应HotSpot的编译请求，并将请求分发给Java实现的即时编译器',
    '允许编译器访问HotSpot中与即时编译相关的数据结构',
    '包括类、字段、方法及其性能监控数据等，并提供这些数据结构在Java语言层面的抽象表示',
    '提供HotSpot代码缓存的Java端抽象表示，允许编译器部署编译完成的二进制机器码'
],
'代码中间表示':[
    '编译器内部：字节码→理想图→优化→机器码',
    {'理想图':[
        '一种有向图，用节点来表示程序中的元素，如变量、操作符、方法、字段等，用边来表示数据或者控制流',
        '本质上将【数据流图】和【控制流图】以某种方式合并，用一种边来表示数据流向，另一种边表示控制流向的图形',
        {'理想图节点两个主操作':[
            '规范化:优化代码，缩减理想图的规模',
            '生成机器码:代码翻译'
        ]}
    ]},
    {'代码优化与生成':[

    ]}
]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 