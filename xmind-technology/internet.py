import xmind
from xmind.core.markerref import MarkerId
w = xmind.load("c:\\Users\\btr\\Desktop\\internet.xmind") 
s2=w.createSheet()
s2.setTitle("internet")
r2=s2.getRootTopic()
r2.setTitle("internet")


content={
'1.浏览器生成消息':[
    {'1.组装HTTP请求消息':[
        {'URL解析':[
            '访问数据源机制（协议）+web服务器名+文件路径名',
            '协议类型：http,ftp,mailto，file'
        ]},
        {'请求消息':[
            '第一行：请求方式 请求地址 协议',
            '第二行：消息头',
            '空行',
            '消息体',
        ]},
        {'响应消息':[
            '第一行：状态码和响应短语',
            '...'
        ]}
    ]},
    {'2.请求DNS查询服务器IP地址':[
        {'根据域名查IP地址':[
            'Socket库：调用网络功能的程序组件集合',
            '协议栈:根据套接字中记录的控制信息来工作的',
            '1.浏览器调用Socket库中的gethostbyname的程序组件(解析器)',
            '2.Socket库中的解析器:组装给DNS服务器的查询消息',
            '3.委托操作系统内部的协议栈发消息给DNS服务器',
            '4.协议栈：通过网卡将消息发送给DNS服务器',
            '5.DNS服务器：将IP地址写入响应消息并返回给客户端',
            '6.消息->网络->客户端，经过协议栈->解析器',
            '7.解析器:读取IP地址，传给应用程序（写入应用程序指定的内存地址）'
        ]},
        {'TCP/IP的基本思路':[
            '子网:通过路由器连接组成的一个大的网络',
            '网络:将子网通过路由器连接起来',
            '1.发送者发出的消息->子网中的集线器->距离发送者最近的路由器',
            '2.路由器根据消息的目的地判断下一个路由器位置，将消息发送到下一个路由器(委托集线器)',
            '3.前面过程不断重复，最终消息就被传送到目的地'
        ]},
        {'IP地址':[
            '网络中，所有的设备都会被分配一个地址',
            '网络号：主机号',
            '子网掩码表示网络号与主机号的边界',
            '子网掩码为1的部分：网络号，子网掩码为0的部分：主机号',
            '主机号全为0：整个子网',
            '主机号全为1：向子网上所有设备发送包，即“广播”'
        ]},
        {'DNS服务器工作原理':[
            '1.客户端首先访问最近一台DNS服务器',
            '2.最近的DNS服务器保存了根域DNS服务器信息，将消息转发给根域DNS服务器',
            '3.根域DNS服务器返回其下com域的DNS服务器,最近的DNS服务器向com域的DNS服务器发送消息',
            '4.com域服务器会返回其下glasscom.com域的DNS服务器的IP地址，最近的DNS服务器向...',
            '5.重复前面步骤,找到目标DNS服务器',
            '实际情况：通过缓存加快DNS服务器的响应'
        ]}
    ]},
    {'3.委托协议栈发送消息':[
        {'1.创建套接字阶段':[
            '调用Socket库中socket程序组件,协议栈返回一个描述符'
        ]},
        {'2.连接阶段':[
            '调用Socket库中connect程序组件',
            '需指定描述符、服务器IP地址和端口号这3个参数',
            '描述符：应用程序用来识别套接字的机制',
            'IP地址和端口号:客户端和服务器之间识别对方套接字的机制'
        ]},
        {'3.通信阶段（收发数据）':[
            '发送消息：调用Socket库中write程序组件',
            '需指定描述符和发送数据',
            '接收消息：调用Socket库中的read程序组件'
        ]},
        {'4.断开阶段':[
            '调用Socket库中的close程序组件',
            'Web服务器会首先调用close来断开连接',
            '浏览器调用read得知收发数据已结束，也会调用close进入断开阶段',
            '一段时间后删除套接字'
        ]}
    ]}],
'2.协议与网卡':[
    {'简要流程':[
        '应用程序：网络应用程序+Socket库',
        {'操作系统的协议栈':[
            'TCP,UDP协议',
            'IP协议+ICMP+ARP'
        ]},
        '网上驱动程序',
        '硬件：网卡'
    ]},
    {'1.创建套接字':[
        '1.分配一个套接字所需内存空间，写入初始状态',
        '2.将表示套接字的描述符告知应用程序',
        'netstat -ano显示套接字内容'
    ]},
    {'2.连接服务器':[
        {'作用':[
            '通信双方交换控制信息,在套接字中记录必要信息',
            '分配缓冲区：一块临时存放要收发的数据的内存空间'
        ]},
        {'通信操作中使用的控制信息':[
            '头部记录的信息',
            '套接字（协议栈中的内存空间）中记录的信息'
        ]},
        {'ACK':[
            {'ACK号等待时间':[
                '据网络包平均往返时间调整ACK号等待时间',
                '滑动窗口与接收缓冲区',
                '滑动窗口：接收方需要告诉发送方自己最多能接收多少数据，发送方根据这个值对数据发送操作进行控制'
            ]},
            '通过“序号”和“ACK号”确认接收方是否收到了网络包',
            'ACK与窗口的合并,减少网络开销'
        ]},
        {'过程':[
            {'1.应用程序':[
                '调用Socket库的connect(<描述符>,<服务器IP地址和端囗号>)，',
                '将IP地址和端口号传递给协议栈中的TCP模块'
            ]},
            {'2.客户端TCP模块':[
                '创建表示连接控制信息的头部:【SYN=1,序号初始值，窗口】',
                '将信息传递给IP模块并委托它进行发送'
            ]},
            '3.客户端IP模块：执行网络包发送操作，网络包通过网络到达服务器',
            '4.服务器的IP模块：将接收到的数据传递给TCP模块',
            {'5.服务器的TCP模块':[
                '根据TCP头部中的信息找到端口号对应的套接字',
                'TCP头部:【ACK=1，窗口,SYN=1,序号初始值】，将其传递给IP模块'
            ]},
            '6.服务器IP模块：执行网络包发送操作，网络包通过网络到达客户端',
            {'7.客户端TCP模块':[
                '通过TCP头部的信息确认连接服务器的操作是否成功',
                '如SYN=1,代表连接成功',
                '向套接字中写入服务器的IP地址、端口号等信息，将状态改为连接完毕',
                '将【ACK设置为1】,将TCP头部传递给IP模块，委托它向服务端返回响应'
            ]}
        ]}
    ]},
    {'3.收发数据':[
        {'将请求消息交给协议栈':[
            '协议栈收到数据不会立即发送，而是将数据放在内部缓冲区，等待应用程序的下一段数据',
            {'发送数据条件':[
                '每个网络包能容纳的数据长度',
                '时间'
            ]},
            'MTU：一个网络包的最大长度，以太网中一般为1500字节',
            'MSS：除去头部之后，一个网络包所能容纳的TCP数据的最大长度',
        ]},
        {'接收HTTP响应消息':[
            '浏览器:在委托协议栈发送请求消息之后，调用read程序来获取响应消息',
            {'协议栈':[
                '响应消息未返回:将应用程序的委托（从接收缓冲区中取出数据并传递给应用程序）挂起',
                '响应消息返回:执行接收操作',
                '检查收到的数据块和TCP头部内容，判断是否有数据丢失，没有问题则返回ACK号',
                '将数据块暂存到接收缓冲区中，并将数据块按顺序连接还原出原始数据',
                '最后将数据交给应用程序'
            ]}
        ]}
    ]},
    {'4.服务器断开连接并删除套接字':[
        '1.服务器的应用程序:调用Socket库的close程序',
        '2.服务器的协议栈:生成包含断开信息的TCP头部,【FIN=1】,套接字记录下断开操作的相关信息,委托IP模块向客户端发送数据,',
        '3.客户端的协议栈:将自己的套接字标记为断开操作状态,向服务器返回一个【ACK号】,等待应用程序来取数据',
        '4.客户端应用程序:调用read来读取数据,被告知来自服务器的数据已经全部收到,调用close来结束数据收发操作',
        '5.客户端的协议栈：生成包含断开信息的TCP头部,【FIN=1】，委托IP模块发送给服务器',
        '6.服务器:返回【ACK号】',
        '7.客户端和服务器的通信全部结束',
        '8.套接字等待一段时间之后再被删除,防止误操作'
    ]},
    {'IP与以太网的包收发操作':[
        '包结构：头部+数据',
        'TCP/IP包：MAC头部（以太网控制信息）+IP头部（IP控制信息）+TCP头部+数据块',
        {'路由器':[
            '使用IP头部，按照【IP规则】传输包的设备',
            'IP协议的表：根据IP头部的目的地信息查出接下来应该发往哪个路由器',
            'IP协议：根据目标地址->下一路由器的MAC地址->委托以太网协议将包传输'
        ]},
        {'集线器':[
            '使用MAC头部，按照【以太网规则】传输包的设备',
            '以太网表：以太网头部中的目的地信息查出相应的传输方向',
            '以太网协议:根据MAC地址->下一个转发设备'
        ]},
        {'IP模块负责添加两个头部':[
            {'MAC头部':[
                '以太网用的头部，包含MAC地址',
                '查询MAC地址需要使用ARP',
                '网卡的ROM中保存着全世界唯一的MAC地址（生产网卡时写入）',
                '网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块'
            ]},
            {'IP头部':[
                'IP用的头部，包含IP地址'
            ]}
        ]},
        {'包收发操作':[
            'TCP模块:在数据块前加上TCP头部，然后整包传递给IP模块',
            'IP模块:在包前加上IP头部和MAC头部，封装好包交给网卡',
            '网卡：将数字信息->电信号或光信号，并通过网线（或光纤）发送出去',
            '信号->集线器、路由器等转发设备->接收方'
        ]},
        {'网卡':[
            {'网卡驱动':[
                '从IP模块获取包，将其复制到网卡内的缓冲区',
                '向MAC模块发送发送包的命令'
            ]},
            {'MAC模块':[
                '将包从缓冲区中取出，生成通用信号',
                '在开头加上报头和起始帧分界符，末尾加上帧校验序列',
                '报头：一段测量时钟信号的特殊信号',
                '起始帧分界符:一个表示包起始位置的标记',
                '帧校验序列:用来检查包传输过程中因噪声导致的波形紊乱、数据错误',
            ]},
            {'PHY（MAU）模块':[
                '信号转换成可在网线中传输的格式，并通过网线发送出去'
            ]}
        ]}
    ]},
    {'用UDP协议收发数据的操作':[
        '适用：不需要重发的数据',
        {'发送':[
            '没有TCP的接收确认、窗口等机制',
            '收发数据前不需要交换控制信息(不需要建立和断开连接)'
        ]},
        {'接收':[
            '根据IP头部中接收方和发送方IP地址',
            'UDP头部中的接收方和发送方端口号',
            '找到相应的套接字将数据交给相应的应用程序'
        ]},
        '应用：音频和视频数据,缺少某些包不会产生严重问题，只会有一些失真或者卡顿'
    ]}],
'3.网线，网络设备':[
    {'双绞线能抑制噪声':[
        '两根信号线的缠绕抵消外源性噪声',
        '节距控制抑制内源性噪声'
    ]},
    {'集线器':[
        '将信号发送给所有连接在它上面的线路',
        '原封不动将信号广播出去'
    ]},
    {'交换机':[
        '全双工模式:同时进行发送和接收操作',
        '端口的MAC模块不具有MAC地址,不核对接收方MAC地址',
        {'交换电路':[
            '通过交换开关切换信息流向',
            '交换开关由电子电路构成，可快速切换'
        ]},
        {'过程':[
            '1.信号到达网线接口，由PHY（MAU）模块进行接收',
            '2.PHY（MAU）模块:信号->通用格式，传递给MAC模块',
            '3.MAC模块:信号->数字信息，通过包末尾的FCS校验错误，没问题,包->缓冲区',
            '4.MAC地址表中查询【包的接收方MAC地址】->【端囗】',
            '5.包->交换电路->缓冲区->MAC模块->PHY模块->端口->网线'
        ]},
        {'MAC地址表维护':[
            '收到包:发送方MAC地址，输入端口->写入MAC地址表',
            '过时自动删除地址表中记录'
        ]},
        {'特殊':[
            '交换机发现一个包要发回到原端口，直接丢弃包'
        ]}
    ]},
    {'路由器':[
        '各个端口都具有MAC和IP地址,只接收与自身地址匹配的包，不匹配直接丢弃',
        {'路由表':[
            '忽略主机号，只匹配网络号',
            '子网掩码:在匹配网络包目标地址时需要对比的比特数',
            {'维护':[
                '手动维护',
                '路由器间的信息交换自行维护'
            ]}
        ]},
        {'转发目标':[
            '路由表',
            '包的IP头部中接收方IP地址',
            '网络号最长，跃点计数较小',
            '网关列为IP地址，该地址为下一个转发目标',
            '网关列为空，IP头部中的接收方IP地址是下一个转发目标',
            '通过ARP来查转发目标的MAC地址'
            '无匹配记录，丢弃包，并通过ICMP消息告知发送方',
            '可设置默认路由'
        ]},
        {'过程':[
            '1.信号->网线接口',
            '2.PHY（MAU）模块和MAC模块:信号->数字信息',
            '3.通过包末尾的FCS进行错误校验:没问题则检查MAC头部中的接收方MAC地址，匹配将包放到缓冲区，否则丢弃',
            '4.通过路由表找到下一路由，更新MAC,IP头部中的TTL,把信号转发出去',
            '5.委托端口模块将包发送出去'
        ]},
        {'分片':[
            '对一个完整的包再进行拆分的过程',
            '条件：长度>输出端口的MTU&&TCP标志字段可分片',
            '不满足：丢弃包，并通过ICMP消息通知发送方'
        ]},
        {'路由器&交换机':[
            'IP （路由器）负责将包发送给通信对象这一整体过程',
            '其中将包传输到下一个路由器的过程则是由以太网（交换机）来负责的'
        ]},
        {'附加功能':[
            '地址转换',
            '包过滤'
        ]}
    ]}],
'4.接入网和网络运营商':[
    {'ADSL接入网':[
        {'互联网与家庭、公司网络不同点':[
            '距离的不同',
            '路由的维护方式'
        ]},
        {'过程':[
            {'客户端生成的网络包':[
                '添加IP头部',
                '添加MAC头部并发送'
            ]},
            {'互联网接入路由器':[
                '接收包，取出IP包',
                '添加PPP,PPPoE,MAC头部',
                '头部：MAC-PPPoE-PPP-IP'
            ]},
            {'ADSL Modem':[
                '接收包',
                '拆分成ATM信元',
                '转换成电信号并发送'
            ]},
            '分离器',
            {'DSLAM':[
                '接收电信号',
                '还原为ATM信元并发送',
                '具有ATM接口，和后方路由器收发数据用的是ATM信元',
            ]},
            {'BAS(宽带接入服务器)':[
                '接收ATM信元',
                '还原网络包',
                '取出PPP包',
                '添加隧道头部并发送',
                '总结：负责将ATM信元还原成网络包并转发到互联网内部'
            ]},
            {'路由器（隧道专用）':[
                '接入隧道包',
                '取出IP包',
                '发送到互联网内部'
            ]}
        ]},
        {'信元':[
            '一个非常小的数据块',
            '开头是有5个字节的头部，后面是48个字节的数据',
            '用于一种叫作ATM的通信技术'
           
        ]},
        {'正交振幅调制（QAM）':[
            '=振幅调制（ASK）+相位调制（PSK）',
            '振幅调制（ASK）:振幅大小对应0和1,振幅小的信号为0，振幅大的信号为1',
            '相位调制（PSK）:信号相位对应0和1,0度开始的波为0，180度开始的波为1',
            'ADSL Modem:采用这种用圆滑波形（正弦波）对信号表示的方式',
            '以太网:采用方波信号表示0和1'
        ]},
        {'ADSL Modem':[
            '将包拆分成信元，并转换成电信号发送给分离器',
            '会持续检查线路质量，动态判断使用的频段数量，以及每个频段分配到的比特数',
            '训练（握手）：Modem通电后，会发送测试信号，根据信号的接收情况判断使用的频段数量和每个频段的比特数，用时几秒到几十秒'
        ]},
        {'分离器':[
            '防止ADSL对电话干扰：信号从电话线传入,分离器需要将电话和ADSL的信号进行分离',
            '防止电话对ADSL干扰:防止拿起放下话筒导致的线路状态改变'
        ]}
    ]},
    {'光纤接入网（FTTH）':[
        {'光纤':[
            '由一种双层结构的纤维状透明材质（玻璃和塑料）构成的',
            '通过纤芯中传导光信号来传输数字信号',
            '数字信息->电信号(1用高电压表示，0用低电压表示)->光信号'
        ]},
        {'单模光纤':[
            '纤芯细，只有角度最小的光线能进入纤',
            '只能传导一条光线,对于光源和光敏元件的性能要求高',
            '信号失真较小'
        ]},
        {'多模光纤':[
            '纤芯粗,可多条光线同时传导',
            '对光源和光敏元件的性能要求低'
        ]},
        {'直连':[
            '互联网接入路由器',
            {'光纤收发器':[
                '将以太网的电信号转换成光信号',
                '连接的光纤一般是单模的'
            ]},
            {'多路光纤收发器':[
                '将光信号转换成电信号',
                '接收端的光敏元件:可根据光的亮度产生不同电压'
            ]},
            'BAS:将包转发到互联网内部',
            '注：上行和下行信号采用不同波长的光，通过棱镜原理进行分离'
        ]},
        {'分路':[
            '互联网接入路由器',
            {'ONU':[
                '将以太网的电信号转换成光信号',
                '通过调整信号收发时机来避免碰撞'
            ]},
            '分光器：让光纤分路，同时连接多个用户',
            'OLT:将光信号转换成电信号',
            '运营商的BAS'
        ]}

    ]},
    {'PPP和隧道':[
        {'在以太网上传输PPP消息':[
            'PPP消息无法转换成信号:其协议中没有定义以太网中的报头，FCS，信号的格式',
            'PPPoE:PPP消息装入以太网包进行传输的方式',
            'MAC-PPPoE-PPP'
        ]},
        {'接入网的整体工作过程':[
            '接入路由器中需要配置运营商分配的用户名和密码',
            '接入路由器:根据PPPoE的发现机制来寻找BAS的MAC地址(广播)',
            {'用户认证和下发配置':[
                '用户在计算机上输入用户名和密码',
                '根据用户名和密码生成PPP消息',
                '将PPP消息装入以太网包进行发送',
                '将以太网包转换成光信号发送',
                '接收光信号还原成以太网包',
                '从以太网包中取出PPP消息交给认证模块',
                '将用户名和密码发给认证服务器，校验用户身份’',
                'BAS下发TCP/IP参数到互联网接入路由器的BAS端的端口'
            ]},
            '客户端:开始发送用来访问互联网的网络包',
            {'BAS':[
                '收到用户路由器发送的网络包后，去掉MAC头部和PPPoE头部',
                '用隧道机制将包发送给网络运营商的路由器'
            ]}
        ]},
        'ADSL和FTTH中，用户和BAS间通过电缆/光纤连接，没必要验证用户身份',
        '登录是为了根据用户名来切换运营商'
    ]},
    {'网络运营商内部':[
        {'POP':[
            'ADSL、FTTH等接入网与用户签约的运营商设备',
            '结构：接入骨干的路由器+交换机+连接用户接入网的路由器',
            '互联网的入口',
            '接入骨干的路由器:需配备转发性能和数据吞吐量高的路由器',
            '连接用户接入网的路由器:需配备大量的端口'
        ]},
        {'连接用户接入网路由器的类型':[
            '一般路由器：专线接入',
            'RAS（路由器）:拔号接入',
            '一般路由器+PPPoE专用BAS:PPPoE',
            '一般路由器+BAS:PPPoA'
        ]},
        {'NOC':[
            '运营商的核心设备',
            '从POP传来的网络包集中到这里，并从这里被转发到离目的地更近的POP或其他的运营商',
            '需配备高性能的路由器'
        ]}
    ]},
    {'跨越运营商的网络包':[
        {'运营商间的路由信息交换':[
            '转接：将互联网中的路由全部告知对方',
            {'对等':[
                '两个运营商间仅告知与各自网络相关的路由信息',
                '通过IX',
                '直接连接'
            ]},
        ]}
    ]}],
'5.局域网':[
    {'防火墙':[
        {'包过滤方式':[
            '根据接收方IP地址',
            '发送方IP地址',
            '接收方端口号',
            '发送方端口号',
            '控制位等信息来判断是否允许某个包通过'
        ]},
        '通过接收方IP地址和发送方IP地址限定流向',
        '通过端口号限定应用程序',
        '通过控制位判断连接方向'
    ]},
    {'负载均衡':[
        '在DNS服务器中填写多个名称相同的记录，每次查询时DNS服务器按顺序返回不同的IP地址',
        '将域名对应的IP地址设置为负载均衡器的IP地址并注册到DNS服务器上,负载均衡器判断将请求转发给哪台Web服务器'
    ]},
    {'缓存服务器':[
        '一台通过代理机制对数据进行缓存的服务器',
        '代理介于Web服务器和客户端之间，具有对Web服务器访问进行中转的功能',
        '进行中转时，可以将Web服务器返回的数据保存在磁盘中，并代替Web服务器将磁盘中的数据返回给客户端',
        {'3种部署方式':[
            '服务器',
            '客户端：归客户端网络运营管理者所有的，Web服务器的运营者无法控制它',
            '互联网边缘：Web服务器运营者和网络运营商签约，将可以自己控制的缓存服务器放在客户端的运营商处'
        ]}
    ]},
    {'代理':[
        '正向代理',
        '反向代理',
        '透明代理'
    ]}],
'6.服务器':[
    {'结构':[
        '等待连接模块',
        '负责与客户端通信的模块'
    ]},
    {'过程':[
        '1.服务器程序启动,读取配置文件,完成初始化操作后，会运行等待连接模块',
        '该模块会创建套接字，然后进入等待连接的暂停状态',
        '2.客户端连发起连接时，该模块会恢复运行并接受连接，然后启动客户端通信模块，并移交完成连接的套接字',
        '客户端通信模块会使用已连接的套接字与客户端进行通信，通信结束后，这个模块就退出了',
        '注：每次有新的客户端发起连接，都会启动一个新的客户端通信模块，其与客户端是一对一的关系'
    ]},
    {'服务器程序调用Socket库':[
        {'1 创建套接字（创建套接字阶段）':[
            '<描述符1>=socket()'
        ]},
        {'2.1 将套接字设置为等待连接状态（等待连接阶段）':[
            'bind(<描述符1>,<端囗号>,...)',
            'listen(<描述符1>,...)'
        ]},
        {'2.2 接受连接（接受连接阶段）':[
            '<描述符2>=accept(<描述符1>,...)',
            '客户端包到达->',
            '协议栈给等待连接的套接字复制一个副本->','将连接对象等控制信息写入新的套接字中'
        ]},
        {'3 收发数据（收发阶段）':[
            'read(<描述符2>,<接收缓冲区>,...)',
            'write(<描述符2>,<发送数据>,...)'
        ]},
        {'4 断开管道并删除套接字（断开阶段）':[
            'close(<描述符2>)'
        ]}
    ]},
    {'使用描述符来指代套接字的原因':[
        '等待连接的套接字中没有客户端IP地址和端口号',
        '使用描述符这一种信息比较简单'
    ]},
    {'接收操作':[
        {'1.网卡接收到信号，将其还原成数字信息':[
            '网卡的MAC模块将网络包从信号->数字信息，校验FCS并存入缓冲区',
            '过程中，服务器的CPU并不是一直在监控网络包的到达，因此并不知道此时网络包已经到达',
            '网卡需要通过中断将网络包到达的事件通知CPU',
            'CPU暂停当前的工作，切换到网卡的任务',
            '网卡驱动会根据MAC头部判断协议类型，并将包交给相应的协议栈',
        ]},
        {'2.协议栈的IP模块的接收操作':[
            '判断是不是发给自己的',
            '判断网络包是否经过分片',
            '将包转交给TCP模块或UDP模块'
        ]},
        {'3.1 TCP模块处理连接包':[
            '确认TCP头部的控制位SYN',
            '检查接收方端口号',
            '为相应的等待连接套接字复制一个新的副本',
            '记录发送方IP地址和端口号等信息'
        ]},
        {'3.2 TCP模块处理数据包':[
            '根据收到的包的发送方IP地址、发送方端口号、接收方IP地址、接收方端口号找到相对应的套接字',
            '将数据块拼合起来并保存在接收缓冲区中',
            '向客户端返回ACK'
        ]},
        {'4. TCP模块的断开操作':[
            '服务器:调用Socket库的close,TCP生成一个控制位FIN为1的TCP头部->客户端',
            '客户端:收到包后,调用close，生成一个FIN为1的TCP头部,一个ACK号->服务器',
            '服务器:再返回ACK号',
            '断开操作完成后，套接字会在一段时间后被删除'
        ]}
    ]},
    '解释请求消息并作出响应',
    '浏览器接收响应消息并显示内容']
}

for key in content:
    t1 = r2.addSubTopic()
    t1.setTopicHyperlink(s2.getID()) 
    list=key.split(":")
    t1.setTitle(list[0])
    if len(list)>1:
        t1.setPlainNotes(list[1]) 
    # print(content[key])
    for i in content[key]:
        # print(type(i))
        if(type(i).__name__=='dict'):
            for t in i:
                t2 = t1.addSubTopic()
                t2.setTopicHyperlink(t1.getID()) 
                t2.setTitle(t)
                for j in i[t]:
                    #print(j)
                    if(type(j).__name__=='dict'):
                        for h in j:
                            t3 = t2.addSubTopic()
                            t3.setTopicHyperlink(t2.getID()) 
                            t3.setTitle(h) 
                            for m in j[h]:
                                if(type(m).__name__=='dict'):
                                    for n in m:
                                        t4 = t3.addSubTopic()
                                        t4.setTitle(n) 
                                        for l in m[n]:
                                            if(type(l).__name__=='dict'):
                                                for k in l:
                                                    t5 = t4.addSubTopic()       
                                                    t5.setTitle(k)
                                                    for p in l[k]:
                                                        if(type(p).__name__=='dict'):
                                                            for u in p:
                                                                t6 = t5.addSubTopic()
                                                                t6.setTitle(u)
                                                                for y in p[u]:
                                                                    if(type(y).__name__=='dict'):
                                                                        for a in y:
                                                                            t7 = t6.addSubTopic()
                                                                            t7.setTitle(a)
                                                                            for b in y[a]:
                                                                                t8 = t7.addSubTopic()
                                                                                t8.setTitle(b)
                                                                    else:
                                                                        t7 = t6.addSubTopic()
                                                                        t7.setTopicHyperlink(t2.getID()) 
                                                                        t7.setTitle(y)              
                                                        else:
                                                            t6 = t5.addSubTopic()
                                                            t6.setTopicHyperlink(t2.getID()) 
                                                            t6.setTitle(p)                                                        
                                            else:
                                                t5 = t4.addSubTopic()
                                                t5.setTopicHyperlink(t3.getID()) 
                                                t5.setTitle(l) 
                                else:
                                    t4 = t3.addSubTopic()
                                    t4.setTopicHyperlink(t3.getID()) 
                                    t4.setTitle(m) 
                    else:
                        t3 = t2.addSubTopic()
                        t3.setTopicHyperlink(t2.getID()) 
                        t3.setTitle(j) 
        else:
            t2 = t1.addSubTopic()
            t2.setTopicHyperlink(t1.getID()) 
            t2.setTitle(i) 



topics=r2.getSubTopics()
for topic in topics:
    topic.addMarker(MarkerId.starBlue)

xmind.save(w,"c:\\Users\\btr\\Desktop\\internet.xmind") 