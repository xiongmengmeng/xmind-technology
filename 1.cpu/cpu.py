import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="cpu"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("cpu")
r2=s2.getRootTopic()
r2.setTitle("程序是怎么跑起来的")


content={
'CPU：解释和运行机器语言的程序内容':[
    {'4部分，电流信号相互连通':[
        {'控制器':[
            '把内存上的指令、数据等读入寄存器',
            '根据指令的执行结果来控制整个计算机'
        ]},
        '运算器：运算从内存读入寄存器的数据',
        '时钟：发出CPU开始计时的时钟信号',
        {'寄存器':[
            '定义：暂存指令、数据等处理对象，可以看作是内存的一种',
            {'主要种类':[
                    '程序计数器：决定程序流程',
                    '累加寄存器',
                    '标志寄存器',
                    '指令寄存器',
                    '栈寄存器',
                    '基址寄存器',
                    '变址寄存器'
                ]}
        ]}]},
    {'机器语言':[
        {'条件分支和循环机制':[
            '程序计数器的值设定为任意地址'
        ]},
        {'函数的调用机制':[
            '在将函数的入口地址设定到程序计数器之前',
            'call指令会把调用函数后要执行的指令地址存储在名为栈的主存内',
            '函数处理完毕后，再通过函数的出口来执行return命令']},
        {'机器语言指令的4种主要类型':[
            '数据传送指令：寄存器与内存，内存与内存，内存与外围之间数据的读写操作',
            '运算指令：用累加寄存器执行算术，逻辑，比较，移位运算',
            '跳转指令：条件分支，循环，强制跳转',
            'call/return指令：函数调用/返回函数调用前的地址'
        ]}
    ]}],
'二进制':[
    {'基础定义':[
        '二进制数表示计算机信息',
        {'为什么':[
            '计算机内部是由IC这种电子部件构成的',
            'IC的一个引脚，只能表示两个状态'
        ]},
        '字节：信息的基本单位，8位二进制数被称为一个字节',
        '位权：数字的位数不同，位权也不同',
    ]},
    {'运算':[
        {'移位运算':[
            '定义：将二进制数值的各数位进行左右移位（shift=移位）的运算'
            '<<表示左移，>>表示右移',
            '<<和>>运算符的左侧是被移位的值，右侧表示要移位的位数',
            '数位移动可以代替乘法运算和除法运算',
            '补数：用正数来表示负数',
            '补数求解：取反+ 1',
            '溢出的位,计算机会直接忽略掉',
            '左移：在空出来的低位补0',
            '右移区分逻辑位移和算术位移,逻辑位移在最高位补0,算术位移:用移位前符号位的值补足',
            '符号扩充：用符号位的值（0或者1）填充高位']},
        {'逻辑运算':[
            '逻辑非（NOT运算）',
            '逻辑与（AND运算）',
            '逻辑或（OR运算）',
            '逻辑异或（XOR运算）']}

    ]},
    {'缺点':[
        '小数运算时出错：一些十进制数的小数无法转换成二进制数',
        {'浮点数:用符号、尾数、基数和指数这四部分来表示的小数':[
            '双精度浮点数类型用64位',
            '单精度浮点数类型用32位来表示全体小数'
        ]}
    ]}],
'内存':[
    {'物理模型':[
        {'内存IC构造':[
            'VCC和GND是电源',
            'A0～A9是地址信号的引脚',
            'D0～D7是数据信号的引脚',
            'RD和WR是控制信号的引脚']},
        {'内存IC大小估算':[
            '数据信号引脚8个：一次可以输入输出8位（=1字节）的数据',
            '地址信号引脚10个：可以指定0000000000～1111111111共1024个地址',
            '地址:表示数据的存储场所',
            '这个内存IC中可以存储1024个1字节的数据，1024=1K,该内存IC的容量就是1KB'
        ]}
    ]},
    {'逻辑模型':[
        '楼房:1层可以存储1个字节的数据，楼层号表示的就是地址'
    ]},
    {'指针':[
        '指针是一种变量，表示的不是数据的值，而是存储着数据的内存的地址',
        '通过使用指针，就可以对任意指定地址的数据进行读写',
        '指针的数据类型表示一次可以读写的长度'
    ]},
    {'数组':[
        '定义：多个同样数据类型的数据在内存中连续排列的形式',
        {'分类':[
            '栈用:使用LIFO（LastInput First Out，后入先出）方式',
            '队列:使用FIFO（First Input First Out，先入先出）方式',
            '链表:更加高效地对数组数据（元素）进行追加和删除处理',
            '二叉查找树:使数据的搜索等更有效率'
        ]}
    ]}],
'磁盘':[
    {'物理结构':[
        '扇区方式',
        '可变长方式'
    ]},
    {'扇区':[
        '定义：对磁盘进行物理读写的最小单位'
        '1个扇区是512字节,1簇=512字节=1扇区',
        '不管是多么小的文件，都会占用1簇的空间',
        '文件占用磁盘空间都是1簇的整数倍'
    ]},
    {'作用':[
        '存储程序,缺点是读取速度慢',
        '应用启动时，程序会由磁盘加载到内存'

    ]},
    {'重要概念':[
         {'虚拟内存':[
            '把磁盘的一部分作为假想的内存来使用',
            '实际上正在运行的程序部分，必须存在在内存中的',
            '为了实现虚拟内存，须把实际内存的内容，和磁盘上的虚拟内存的内容进行部分置换（swap），并同时运行程序',
            '虚拟内存的方法有分页式和分段式,页大小为4KB',
            '虚拟内存能避免因内存不足导致的应用无法启动',
            '虚拟内存使用时发生的Page In和Page Out往往伴随着低速的磁盘访问，这个过程中应用的运行会变得迟钝']},
         {'磁盘缓存（disk cache）':[
             '从磁盘中读出的数据存储到内存空间中']}
    ]},
    {'节省内存的方法':[
        '通过DLL（Dynamic Link Library）文件实现函数共有:程序运行时可以动态加载Library（函数和数据的集合）的文件',
        '通过调用_stdcall来减小程序文件的大小'
    ]}],
'文件压缩':[
    '文件：字节数据的集合体',
    {'压缩算法':[
        {'RLE算法':[
            '把文件内容用“数据×重复次数”的形式压缩',
            '缺点:文本文件中，同样字符多次重复出现的情况较少',
            '适用于压缩图像，exe文件']},
        {'哈夫曼算法':[
            '多次出现的数据用小于8位的字节数来表示，不常用的数据则可以用超过8位的字节数来表示',
            '为各压缩对象文件分别构造最佳的编码体系，并以该编码体系为基础来进行压缩',
            '用二叉树实现哈夫曼编码:构建能够明确进行区分的编码体系',
            '应用：压缩软件LHA'
        ]}
    ]},
    {'可逆压缩和非可逆压缩':[
        '原始的图像文件是BMP格式',
        'JPEG格式的文件是非可逆压缩，还原后的图像信息有一部分是模糊的',
        'GIF格式的文件是可逆压缩，但因为有色数不能超过256色的限制，还原后颜色信息会有一些缺失'
    ]}],
'运行环境=操作系统 + 硬件':[
    {'硬件':[
        'CPU',
        '存储程序指令和数据的内存',
        '通过I/O连接的键盘、显示器、硬盘、打印机等外围设备'
    ]},
    {'CPU':[
        '负责解析并运本地代码',
        '机器语言的程序称为本地代码（native code）',
        '源代码:程序员用C语言等编写的程序，在编写阶段仅仅是文本文件',
        '通过对源代码进行编译，就可以得到本地代码']},
    {'Windows操作系统':[
        '前身是监控程序:加载和运行程序',
         {'3部分':[
            '硬件控制程序:硬件控制，程序运行控制',
            '编程语言处理器（汇编、编译、解析）',
            '各种实用程序：调试工具，dump程序，文本编辑器'
         ]},
         {'特征':[
            '克服了除CPU以外的硬件差异',
            {'应用通过操作系统API间接控制硬件':[
                '键盘输入、显示器输出等是通过向Windows发送指令间接实现向硬件发送指令',
                '系统调用（system call）:操作系统通过函数来控制硬件的形为',
                '使硬件抽象化:文件是操作系统对磁盘媒介空间的抽象化',
                '通过API函数集来提供系统调用,API通过多个DLL文件来提供',
            ]},
            'GUI（Graphical User Interface，图形用户界面）',
            '多任务:Windows是通过时钟分割技术来实现同时运行多个程序的功能'
        ]}  
    ]},
    {'源代码的运行方案':[
        'Unix系列操作系统FreeBSD中Ports的机制,能够结合当前运行的硬件环境来编译应用的源代码，进而得到本地代码',
        '利用虚拟机获得其他操作系统环境',
        {'JAVA':[
            '提供不依赖于特定硬件及操作系统的程序运行环境',
            'Java编译器:将程序员编写的源代码（sample.java）转换成字节码（sample.class）',
            'Java虚拟机（java.exe）:把字节代码变换成x86系列CPU适用的本地代码',
            '由x86系列CPU负责实际的处理',
            '从操作系统方面来看，Java虚拟机是一个应用，而从Java应用方面来看，Java虚拟机就是运行环境'
        ]}
    ]}],
'编绎':[
    {'基础概念':[
        {'本地语言':[
            'Windows中EXE文件的程序内容,cpu可以运行的语言'
        ]},
        {'编绎':[
            '定义：将高级编程语言编写的源代码转换成本地语言的过程',
            {'编绎器种类由3点决定':[
                 '编程语言',
                '电脑的CPU',
                '电脑的操作系统'
            ]}
        ]},
        {'链接':[
            '把多个目标文件结合，生成1个EXE文件的处理'
        ]},
        {'库文件':[
            '把多个目标文件集成保存到一个文件中的形式',
            {'种类':[
                '导入库:库文件存储着两个信息，一是A函数在某DLL文件中，一个是存储着DLL文件的文件夹信息',
                '静态链接库:存储着目标文件的实体，能直接和EXE文件结合的库文件'
            ]}
        ]},
        {'标准函数':[
            '不是通过源代码形式而是通过库文件形式和编译器一起提供的函数'
        ]},
        {'再配置信息':[
            '在程序运行时，虚拟的内存地址会转换成实际的内存地址',
            '链接器会在EXE文件的开头，追加转换内存地址所需的必要信息'
        ]}
    ]},
    {'链接后的EXE文件的构造':[
        '再配置信息',
        '变量组和函数组',
        '给变量及函数分配了虚拟的内存地址',
    ]},
    {'运行后EXE文件的内容':[
        '变量组',
        '函数组',
        {'栈':[
            '用来存储函数内部的局部变量，以及函数调用时所用的参数的内存区域',
            '对数据进行存储和舍弃（清理处理）的代码，是由编译器自动生成的',
            '当函数被调用时都会得到申请分配，在函数处理完毕后会自动释放'
        ]},
        {'堆':[
            '用来存储程序运行时的任意数据及对象的内存领域',
            '堆的内存空间，要根据程序员编写的程序，来明确进行申请分配或释放'
        ]}
    ]}],
'汇编语言':[
    {'基础概念':[
        '助记符',
        {'汇编语言':[
            '使用助记符的编程语言',
            '文件的扩展名，常用“.asm”来表示',
            '汇编语言编写的源代码，和本地代码是一一对应的',
            'C语言的源代码同本地代码不是一一对应的，反编译后的代码和源代码可能不一样'
        ]},
        {'段定义':[
            '定义：给构成程序的命令和数据的集合体加上一个名字',
            '由伪指令segment和ends围起来',
            '_TEXT：指令的段定义',
            '_DATA：被初始化（有初始值）的数据的段定义',
            '_BSS：尚未初始化的数据的段定义',
            'group：把_BSS和_DATA这两个段定义汇总为名为DGROUP的组',
            '伪指令proc和endp围起来的部分:过程（procedure）的范围',
            'end:源代码的结束'
        ]}
    ]},
    {'语法:操作码+操作数':[
        {'操作码':[
            'mov A,B:把B值赋给A',
            'add A,B:A与B的值相加，结果赋值给A',
            'push A:把A的值存储在栈中',
            'pop A:从栈中读取出值，赋给A',
            'cmp A,B:对A跟B的值进行比较，比较结果会自动存入标志寄存器',
            'jge/jl/jle 标签名：和cmp命令组合使用，跳转到标签行'
            'inc A:A的值加1',
            'jmp 标签名：将控制无条件跳转到指定标签行',
            'call A:调用函数A',
            'ret 无：将处理返回到函数的调用源',
            'xor A,B:A和B的位进行异或比较，并将结果存入A中'
        ]},
        {'操作数':[
            '内存地址',
            '常数',
            {'寄存器名':[
                'eax 累加寄存器  运算',
                'ebx 基址寄存器  存储内存地址',
                'ecx 计数寄存器  计算循环次数',
                'edx 数据寄存器  存储数据',
                'esi 源基址寄存器   存储数据发送源的内存地址',
                'edi 目标基址寄存器 存储数据发送目标的内存地址',
                'ebp 扩展基址指针寄存器 存储数据存储领域基点内存地址',
                'esp 扩展栈指针寄存器   存储栈中最高位数据的内存地址'
            ]}
        ]},
        {'函数':[
            '函数调用机制',
            '函数内部的处理：函数的参数是通过栈来传递，返回值是通过寄存器来返回的'
        ]},
        {'其它':[
            '全局变量',
            '循环处理的实现方法:xor inc com jl',
            '条件分支的实现方法:com jle jge jmp'
        ]}
    ]},
    {'流程':[
        '加载本地代码到内存，内存中存储着构成本地代码的指令和数据',
        '程序运行时，CPU会从内存中把指令和数据读出，将其存储在CPU内部的寄存器中进行处理'
    ]}
],
'外围设备控制':[
    {'识别外围设备的3种方式':[
        {'I/O端口号':[
            {'基础概念':[
                {'I/O 控制器':[
                    '计算机主机中，附带了用来连接显示器及键盘等外围设备的连接器',
                    '各连接器的内部，都连接有用来交换计算机主机同外围设备之间电流特性的IC'
                ]},
                {'I/O是Input/Output的缩写':[
                    '显示器、键盘等外围设备都有各自专用的I/O控制器',
                    'I/O控制器中有用于临时保存输入输出数据的内存',
                    '这个内存就是端口'
                ]},
                'CPU内部的寄存器是用来进行数据运算处理的，而I/O寄存器则主要是用来临时存储数据的'
            ]}
        ]},
        {'IRQ(Interrupt Request 中断处理）':[
            '定义：用来暂停当前正在运行的程序，并跳转到其他程序运行的必要机制',
            '实施中断请求的是连接外围设备的I/O控制器，负责实施中断处理程序的是CPU',
            '中断控制器会把从多个外围设备发出的中断请求有序地传递给CPU',
            '实时处理从外围设备输入的数据',
            {'中断请求的顺序':[
                '寄存器的备份：把CPU所有寄存器的数值保存到内存的栈中',
                '外围设备控制：在中断处理程序中完成外围设备的输入输出',
                '寄存器的还原：把栈中保存的数值还原到CPU寄存器中',
                '主程序的处理']}
        ]},
        {'DMA(Direct Memory Access)':[
            '在不通过CPU的情况下，外围设备直接和主内存进行数据传送',
            '可以实现短时间内传送大量数据,因为CPU作为中介的时间被节省了',
            '像磁盘这样用来处理大量数据的外围设备都具有DMA功能'
        ]}
    ]},
    {'例子':[
            '显示器中显示的信息一直存储在某内存中，该内存称为VRAM（VideoRAM）',
            '在程序中，只要往VRAM中写入数据，该数据就会在显示器中显示出来，会借助中断来进行处理',
            '显卡中一般都配置有与主内存相独立的VRAM和GPU（图形处理器）'
        ]}]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 