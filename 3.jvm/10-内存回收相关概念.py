import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("内存回收相关概念")
r2=s2.getRootTopic()
r2.setTitle("内存回收相关概念")


content={
'根节点枚举':[
    'HotSpot使用一组称为【OopMap】的数据结构',
    {'类加载完成时':[
        '把对象内什么偏移量上是什么类型的数据计算出来'
    ]},
    {'即时编译过程中':[
        '在特定的位置记录下栈里和寄存器里哪些位置是引用'
    ]}
],
'安全点:GC时机':[
    '以【是否具有让程序长时间执行的特征】为原则进行选定',
    {'可能会设置有安全点的位置':[
        '方法调用',
        '循环跳转',
        '异常跳转'
    ]},
    {'可数循环':[
        '使用int类型或范围更小的数据类型作为索引值的循环'
    ]},
    {'不可数循环':[
        '使用long或者范围更大的数据类型作为索引值的循环',
        '虚拟机为了避免安全点过多，对循环做了优化，【不可数循环】才会被放置安全点'
    ]},
    {'两种方案':[
        {'抢先式中断':[
            '所有用户线程都中断',
            '如有用户线程中断不在安全点上，恢复线程，跑到安全点上再中断'
        ]},
        {'主动式中断':{
            '设一个标志位，线程执行过程不断轮询，标志为真自己在最近安全点中断挂起',
            '轮询标志的地方和安全点是重合的'
        }}
    ]},
],
'安全区域':[
    '确保在某一段代码片段之中，引用关系不会发生变化'
],
'记忆集与卡表':[
    {'记忆集':[
        '一种用于记录从非收集区域指向收集区域指针集合的抽象数据结构',
        '缩减GC Roots扫描范围'
    ]},
    {'卡精度':[
        '每个记录精确到一块内存区域，该区域内有对象含有跨代指针',
        '目前最常用的一种记忆集实现形式'
    ]},
    '卡页中有一个对象的字段存在着跨代指针，对应卡表的数组元素值标识为1，称元素变脏,没有标识为0',
    '垃圾收集发生时，筛选出卡表中变脏的元素，加入GC Roots中一并扫描',
    {'写屏障':[
        '维护卡表状态'
    ]}
],
'并行':[
    '一个处理器核处理一个任务',
    '同一时间多条垃圾收集器线程协同工作，默认此时用户线程处于等待状态'
],
'并发':[
    '一个处理器核处理多个任务',
    '同一时间垃圾收集器线程与用户线程都在运行'
]


}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 