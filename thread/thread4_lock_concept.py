import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="thread"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("lock_base")
r2=s2.getRootTopic()
r2.setTitle("锁基础")


content={
'乐观锁/悲观锁':[
    '悲观锁，乐观锁适',
    '悲观锁:适合写操作多的场景,在Java中使用，是利用各种锁',
    '乐观锁,合读操作多的场景，不加锁会带来性能提升,在Java中使用，是无锁编程，常采用CAS算法'
],
'伪共享':[
    '产生原因：多变量放入一个缓存行，并且多线程同时去写入缓存行中不同的变量',
    '缓存与内存交换数据的单位就是缓存行',
    '当CPU要访问的变量没有在缓存中，会把该变量所在内存中大小为缓存行的内存放入缓存行'
],
'偏向锁/轻量级锁/重量级锁':[
    '通过对象监视器在对象头中的字段来表明的',
    '无锁->偏向锁->轻量级锁->重量级锁,锁状态只能升级不能降级,提高获取锁和释放锁的效率',
    {'偏向锁':[
        '目标:在只有一个线程执行同步代码块时提高性能',
        {'过程':[
            '一个线程访问同步代码块:cas操作，用threadId替换mark word',
            '再次访问同步代码快：检查threadID是否是自己(无cas)'
        ]},
        {'锁升级条件':[
            '其他线程尝试竞争偏向锁时',
            '持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁'
        ]}
    ]},
    {'轻量级锁':[
        '锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁,另一线程自旋',
        {'过程':[
            {'加锁':[
                '1.代码进入同步块，如同步对象锁为无锁状态01',
                '2.虚拟机在当前线程的栈帧中建立名为锁记录（Lock Record）的空间',
                '3.让锁记录中Object reference指向锁对象',
                '尝试用cas替换Object的Mark Word,将Mark Word的值存入琐记录',
                '4.cas成功，对象头中存储了锁记录地址和状态00(对象处于轻量级锁定)',
                '5.cas失败，如是自己执行了锁重入，添加一条Lock Record作为重入计数',
                '如其它线程已持有了该Object的轻量级锁，表明有竞争，进入锁膨胀过程',
            ]},
            {'解锁':[
                '1.取值null的锁记录，表示有重入，重置锁记录，表示重入计数减一',
                '2.值不为null，使用cas将Mark Word值恢复给对象头',
                '成功->解锁成功',
                '失败->轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流'
            ]}
        ]},
        {'锁膨胀':[
            '1.当Thread-1进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁',
            '2.Thread-1加轻量级锁失败，进入锁膨胀流程',
            '为Object对象申请Monitor锁',
            '让Object指向重量级锁地址然后自己进入Monitor的EntryList BLOCKED',
            '3.当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败',
            '->进入重量级解锁流程，即按照Monitor地址找到Monitor对象',
            '->设置Owner为null，唤醒EntryList中BLOCKED线程'
        ]},
        {'自旋':[
            '好处:减少线程上下文切换的消耗',
            '缺点:循环会消耗CPU'
        ]}
    ]},
    {'重量级锁':[
        '当锁为轻量级锁时，另一个线程自旋，但不会一直自旋->',
        '自旋一定次数还没有获取到锁，进入阻塞->',
        '该锁膨胀为重量级锁,锁标志的状态值变为10',
        'Mark Word中存储的是指向重量级锁的指针，等待锁的线程都会进入阻塞状态,性能降低'
    ]},
    {'综上':[
        '偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作',
        '轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能',
        '重量级锁是将除了拥有锁的线程以外的线程都阻塞'
    ]}
],
'自旋锁 VS 适应性自旋锁 ':[
    {'自旋锁':[
        '线程挂起和恢复现场的花费>用户代码执行时长',
        '避免了线程切换的开销，但它要占用处理器时间',
        '如锁被占用时间很长，自旋线程只会浪费处理器资源',
        '所以自旋等待时间要有一定限度，没有成功获得锁，就应当挂起线程',
        'do-while循环就是一个自旋操作',
        'JDK 6中变为默认开启',
        '自旋锁是使用CPU时间换取线程阻塞与调度的开销'
    ]},
    {'适应性自旋锁':[
        '自旋时间（次数）不固定:由前一次在同一个锁上的自旋时间及锁的拥有者的状态决定',
        '如在同一个锁对象上，自旋等待刚成功获得过锁，并且持有锁的线程正在运行中',
        '虚拟机会认为这次自旋也很有可能成功，进而允许自旋等待更长时间',
        '如对于某个锁，自旋很少成功获得过，以后尝试获取这个锁时将省略自旋，直接阻塞线程，避免浪费处理器资源'
    ]},
    '自旋锁中 另有三种常见的锁形式:TicketLock、CLHlock和MCSlock'

],
'公平锁 VS 非公平锁':[
    {'公平锁':[
        '多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁',
        '优点:等待锁的线程不会饿死',
        '缺点:整体吞吐效率相对非公平锁低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大',
        '通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性',
        ''
    ]},
    {'非公平锁':[
        '多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待',
        '如此时锁刚好可用，这个线程可以无需阻塞直接获取到锁，所以有可能出现后申请锁的线程先获取锁的场景',
        '优点:减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程',
        '缺点:处于等待队列中的线程可能会饿死，或者等很久才会获得锁'
    ]}
],
'可重入锁 VS 非可重入锁':[
    {'可重入锁':[
        'Java中ReentrantLock和synchronized',
        '优点是可一定程度避免死锁',
        'ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0'
    ]},
    {'获取锁':[
        '可重入锁:尝试获取并更新status值，如status == 0表示没有其他线程在执行同步代码，把status置为1，当前线程开始执行',
        '如status != 0，判断当前线程是否是获取到这个锁的线程，如果是执行status+1，且当前线程可以再次获取锁',
        '非可重入锁:直接去获取并尝试更新当前status的值，如果status != 0的话会获取锁失败，当前线程阻塞'
    ]},
    {'释放锁':[
        '可重入锁:先获取当前status的值，在当前线程是持有锁的线程的前提下,如status-1 == 0',
        '表示当前线程所有重复获取锁的操作都已经执行完毕，该线程会真正释放锁',
        '非可重入锁:在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放'
    ]}
],
'独享锁 VS 共享锁':[
    {'独享锁':[
        '即排他锁，指该锁一次只能被一个线程所持有',
        '如线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁',
        '获得排它锁的线程即能读数据又能修改数据',
        'JDK中的synchronized和JUC中Lock的实现类就是互斥锁'
    ]},
    {'共享锁':[
        '该锁可被多个线程所持有',
        '如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁',
        '获得共享锁的线程只能读数据，不能修改数据',
        'ReentrantReadWriteLock有两把锁：ReadLock和WriteLock(靠内部类Sync(AQS的一个子类)实现的锁)'
    ]}
]


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 