import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm_methodCall")
r2=s2.getRootTopic()
r2.setTitle("jvm_方法调用")


content={



'任务':['不等同于方法执行，该阶段唯一任务是确定被调用方法版本，不涉及方法内部具体运行过程'],
'五条字节码指令':[
    'invokestatic：调用静态方法',
    'invokespecial：调用实例构造器<init>()方法、私有方法和父类中的方法',
    'invokevirtual：调用所有的虚方法',
    'invokeinterface：调用接口方法，在运行时确定一个实现该接口的对象',
    'invokedynamic：运行时动态解析出调用点限定符所引用的方法，然后再执行该方法'
],
'解析':[
    {'定义':[
        '静态过程',
        '编译期间确定',
        '把符号引用转变为直接引用,确定唯一的方法调用版本',
        '如能被invokestatic和invokespecial指令调用的方法'
    ]},
    {'分类':[
        '静态方法:与类型直接关联，不能通过重写出现别的版本，适合类加载阶段进行解析',
        '私有方法:外部不可被访问，不能通过继承出现别的版本，适合类加载阶段进行解析',
        '实例构造器',
        '父类方法',
        '被final修饰的方法（invokevirtual指令调用)：无法被覆盖，没有其他版本的可能'
    ]},
],
'分派':[
    {'静态分派':[
        {'定义':[
            '依赖静态类型决定方法执行版本',
            '发生在编译阶段，不由虚拟机来执行的',
            '典型表现:方法重载'
        ]},
        {'重载':[
            '通过参数的静态类型而不是实际类型作为判定依据的',
            '静态类型是在编译期可知',
            '实际类型在运行期才可确认'
        ]},
        {'重载时目标方法选择优先级':[
            '1.char>int>long>float>double的顺序转型进行匹配',
            '2.一次自动装箱,封装类型java.lang.Character',
            '3.java.lang.Serializable,是java.lang.Character类实现的一个接口',
            '自动装箱之后还是找不到装箱类，会找装箱类所实现的接口类型',
            '3.Object,如果有多个父类，那将在继承关系中从下往上开始搜索',
            '4.变长参数的重载优先级是最低的'
        ]}
    ]},
    {'动态分派':[
        {'定义':[
            '运行期根据实际类型确定方法执行版本的分派动作',
            '典型表现:重写（Override）'
        ]},
        {'invokevirtual指令运行时解析过程':[
            '1.找到操作数栈顶的第一个元素所指向的对象实际类型，记作C',
            '2.在类型C中找到与常量中的描述符和简单名称都相符的方法',
            '找得到，进行访问权限校验',
            '通过则返回方法的直接引用，查找过程结束',
            '不通过则返回java.lang.IllegalAccessError异常',
            '3.找不到，按照继承关系从下往上对C的各个父类进行搜索和验证',
            '4.如始终没有找到合适的方法，抛出java.lang.AbstractMethodError'
        ]},
        {'方法重写本质':[
            'invokevirtual指令执行的第一步：在运行期确定接收者的实际类型',
            '根据方法接收者的实际类型来选择方法版本',
            '把常量池中方法的符号引用解析到直接引用上'
        ]}
    ]},
    {'单分派与多分派':[
        '方法的宗量：方法的接收者与参数',
        '单分派：根据一个宗量对目标方法进行选择',
        '多分派: 根据多个宗量对目标方法进行选择',
        {'静态分派,选择目标方法的依据':[
            '静态类型',
            '方法参数',
            'Java语言的静态分派属于多分派类型,根据两个宗量进行选择'
        ]},
            {'动态分派,选择目标方法的依据':[
            '方法接受者的实际类型'
        ]}
    ]},
    {'动态分派实现':[
        '方法版本选择过程需在【接收者类型的方法元数据】中搜索目标方法',
        '优化手段:为类型在方法区中建【虚方法表】,使用虚方法表索引来代替元数据查找',
        '虚方法表在类加载连接阶段进行初始化，类的变量初始值后，把类的虚方法表一同初始化'
    ]}
]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 