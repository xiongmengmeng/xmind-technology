import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm_memoryModel")
r2=s2.getRootTopic()
r2.setTitle("Java内存模型")


content={
'前言知识：CPU与内存':[
    {'矛盾':[
        '速度差距大，时间都花费在磁盘I/O、网络通信或者数据库访问上'
    ]},
    {'解决方案：高速缓存':[
        '作为内存与CPU间的缓冲',
        '读写速度接近CPU运算速度',
        {'缓存一致性协议':[
            '解决多CPU运算任务涉及一块主内存时',
            '导致各自的缓存数据不一致问题'
        ]}
    ]}
],
'目的':[
    '定义程序中各种变量的访问规则'
],
'重要概念':[
    '主内存:所有的变量都存储其上（类比物理硬件内存）',
    '工作内存：每条线程一份（类比CPU缓存），保存线程使用变量的主内存副本',
    '线程对变量的操作在工作内存进行，不直接读写主内存中数据'
],
'内存间交互操作':[
    {'8种':[
        {'lock（锁定）':[
            '作用于主内存变量',
            '标识一条线程独占的状态'
        ]},
        {'unlock（解锁）':[
            '作用于主内存变量',
            '把一个处于锁定状态的变量释放出来'
        ]},
        {'read（读取）':[
            '作用于主内存变量',
            '把变量值从主内存传输到线程的工作内存，以便load动作使用'
        ]},
        {'load（载入）':[
            '作用于工作内存变量',
            '把read操作从主内存中得到的变量值放入工作内存中'
        ]},
        {'use（使用）':[
            '作用于工作内存变量',
            '把工作内存中的变量值传递给执行引擎',
            '虚拟机遇到使用变量值的字节码指令时执行此操作'
        ]},
        {'assign（赋值）':[
            '作用于工作内存变量',
            '把从执行引擎接收的值赋给变量',
            '虚拟机遇到给变量赋值的字节码指令时执行此操作'
        ]},
        {'store（存储）':[
            '作用于工作内存变量',
            '把工作内存中变量的值传送到主内存，以便write操作使用'
        ]},
        {'write（写入）':[
            '作用于主内存变量',
            '把store操作从工作内存中得到的变量值放入主内存的变量'
        ]}
    ]},
    {'规则限定':[
        '一个新的变量只能在主内存中诞生',
        '一个变量从主内存拷贝到工作内存，要按顺序执行read和load操作',
        '变量从工作内存同步回主内存，要按顺序执行store和write操作',
        '对一个变量执行unlock操作前，需要把变量同步回主内存中（执行store、write操作）'
    ]}
],
'volatile修饰变量':[
    {'变量对所有线程可见':[
        '但并发不安全，因运算操作符并非原子操作，如果a++,由4条字节码指令构成',
        '一条字节码指令解释执行，解释器要运行许多行代码才能实现它的语义',
        '一条字节码指令编译执行，可能转化成若干条本地机器码指令'
    ]},
    {'禁止指令重排序优化':[
        'lock addl$0x0，(%esp)作用:相当于一个内存屏障（重排序时不能把后面的指令重排到内存屏障前)',
        'lock前缀:将本处理器的缓存写入了内存&&引起别的处理器或者别的内核无效化其缓存',
        '这样一个空操作，可让volatile变量的修改对其他处理器立即可见'
    ]}
],
'原子性、可见性与有序性':[
    {'原子性':[
        'read、load、assign、use、store和write六个',
        '基本数据类型访问、读写都具备原子性',
        '更大范围原子性保证:lock和unlock'
    ]},
    {'可见性':[
        '实现可见性的关键字：synchronized，final和volatile',
        {'synchronized':[
            '对变量执行unlock操作前，须先把此变量同步回主内存中'
        ]},
        {'final':[
            '字段在构造器中一旦被初始化完成，其他线程中就能看见final字段的值'
        ]},
        {'volatile':[
            '新值能立即同步到主内存，以及每次使用前立即从主内存刷新'
        ]}
    ]},
    {'有序性':[
        '在本线程内观察，所有操作都是有序的:线程内似表现为串行',
        '在A线程中观察B线程，所有操作都是无序的:指令重排序和工作内存与主内存同步延迟'
    ]}
],
'先行发生规则':[
    '程序次序规则',
    '管程锁定和volatile变量规则',
    '线程启动,终止,中断，终结规则',
    '传递性规则',
    '时间顺序与先行发生原则无因果关系，衡量并发安全问题以先行发生原则为准'
]

}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 