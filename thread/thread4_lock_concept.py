import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="thread"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("lock_base")
r2=s2.getRootTopic()
r2.setTitle("锁基础")


content={
'乐观锁/悲观锁':[
    '线程要不要锁住同步资源',
    '悲观锁:适写操作多场景,在Java中使用，是利用各种锁',
    '乐观锁,适读操作多场景,在Java中使用，是无锁编程，常用CAS算法'
],
'伪共享':[
    '缓存系统中是以缓存行(cache line)为单位存储的',
    '当多线程修改互相独立的变量时,如果这些变量共享同一个缓存行',
    '就会无意中影响彼此的性能(番发送RFO消息，占得缓存行的拥有权)',
    {'避免':[
        '缓存填充：让不同线程操作的对象处于不同的缓存行',
        '使用编译指示，强制使每一个变量对齐'
    ]}
],
'偏向锁/轻量级锁/重量级锁':[
    '通过对象监视器在对象头中的字段来表明的',
    '无锁->偏向锁->轻量级锁->重量级锁,锁状态只能升级不能降级,提高获取锁和释放锁的效率',
    {'偏向锁':[
        '目标:在只有一个线程执行同步代码块时提高性能',
        {'过程':[
            '一个线程访问同步代码块:cas操作，用threadId替换mark word',
            '再次访问同步代码快：检查threadID是否是自己(无cas)'
        ]},
        {'锁升级条件':[
            '其他线程尝试竞争偏向锁时',
            '持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁'
        ]}
    ]},
    {'轻量级锁':[
        '锁是偏向锁时，被另一个线程所访问，偏向锁会升级为轻量级锁,另一线程自旋',
        {'过程':[
            {'加锁':[
                '1.代码进入同步块，如同步对象锁为无锁状态01',
                '2.虚拟机在当前线程的栈帧中建立名为锁记录（Lock Record）的空间',
                '3.让锁记录中Object reference指向锁对象',
                '尝试用cas替换Object的Mark Word,将Mark Word的值存入琐记录',
                '4.cas成功，对象头中存储了锁记录地址和状态00(对象处于轻量级锁定)',
                '5.cas失败，如是自己执行了锁重入，添加一条Lock Record作为重入计数',
                '如其它线程已持有了该Object的轻量级锁，表明有竞争，进入锁膨胀过程',
            ]},
            {'解锁':[
                '1.取值null的锁记录，表示有重入，重置锁记录，表示重入计数减一',
                '2.值不为null，使用cas将Mark Word值恢复给对象头',
                '成功->解锁成功',
                '失败->轻量级锁进行了锁膨胀或已经升级为重量级锁，进入重量级锁解锁流'
            ]}
        ]},
        {'锁膨胀':[
            '1.当Thread-1进行轻量级加锁时，Thread-0 已经对该对象加了轻量级锁',
            '2.Thread-1加轻量级锁失败，进入锁膨胀流程',
            '为Object对象申请Monitor锁',
            '让Object指向重量级锁地址然后自己进入Monitor的EntryList BLOCKED',
            '3.当Thread-0退出同步块解锁时，使用cas将Mark Word的值恢复给对象头，失败',
            '->进入重量级解锁流程，即按照Monitor地址找到Monitor对象',
            '->设置Owner为null，唤醒EntryList中BLOCKED线程'
        ]},
        {'自旋':[
            '好处:减少线程上下文切换的消耗',
            '缺点:循环会消耗CPU'
        ]}
    ]},
    {'重量级锁':[
        '当锁为轻量级锁时，另一个线程自旋，但不会一直自旋->',
        '自旋一定次数还没有获取到锁，进入阻塞->',
        '该锁膨胀为重量级锁,锁标志的状态值变为10',
        'Mark Word中存储的是指向重量级锁的指针，等待锁的线程都会进入阻塞状态,性能降低'
    ]},
    {'综上':[
        '偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作',
        '轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能',
        '重量级锁是将除了拥有锁的线程以外的线程都阻塞'
    ]}
],
'自旋锁VS适应性自旋锁 ':[
    {'自旋锁':[
        {'适用':[
            '线程挂起和恢复现场的时长>用户代码执行时长'
        ]},
        {'评价':[
            '避免线程切换开销',
            '但占用处理器时间',
            '使用CPU时间换取线程阻塞与调度的开销'
        ]},
        '自旋等待时间要有限度，没有成功获得锁，应当挂起线程',
        'do-while循环就是一个自旋操作',
        {'三种常见的锁形式':[
            'TicketLock',
            'CLHlock',
            'MCSlock'
        ]}
    ]},
    {'适应性自旋锁':[
        '自旋时间或次数不固定:由前一次在同一个锁上的自旋时间及锁拥有者的状态决定',
        {'情况1':[
            '如在同一个锁对象上',
            '自旋等待刚成功获得过锁，并且持有锁的线程正在运行中',
            '虚拟机认为这次自旋很有可能成功',
            '进而允许自旋等待更长时间'
        ]},
        {'情况2':[
            '如某个锁自旋很少成功获得过',
            '以后尝试获取这个锁将省略自旋',
            '直接阻塞线程，避免浪费处理器资源'
        ]}

    ]}
],
'公平锁VS非公平锁':[
    '多线程竞争锁时要不要排队',
    {'公平锁':[
        '通过同步队列实现多线程按照申请锁的顺序来获取锁，实现公平特性',
        '优点:等待锁的线程不会饿死',
        '缺点:整体吞吐效率比非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大'
    ]},
    {'非公平锁':[
        '多线程直接尝试获取锁，如锁刚好可用，线程获取到锁，否则到队列的队尾等待',
        '优点:减少唤起线程的开销，整体的吞吐效率高，因线程有几率不阻塞直接获得锁',
        '缺点:处于等待队列中的线程可能会饿死，或等很久才会获得锁'
    ]}
],
'可重入锁VS非可重入锁':[
    '一个线程在多个流程能不能获得同一把锁',
    {'可重入锁':[
        'Java中ReentrantLock和synchronized',
        '优点：一定程度避免死锁',
        'AQS中维护了一个同步状态status来计数重入次数'
    ]},
    {'获取锁':[
        {'可重入锁':[
            '尝试获取并更新status值',
            '如status==0，CAS把status置为1，当前线程开始执行',
            '如status!=0，判断当前线程是否是获取到这个锁的线程，如是执行status+1'
        ]},
        '非可重入锁:直接去获取并尝试更新status，如status!=0获取锁失败，当前线程阻塞'
    ]},
    {'释放锁':[
        {'可重入锁':[
            '当前线程是持有锁的线程&&status-1==0',
            'status置为0,将锁释放'
        ]},
        '非可重入锁:当前线程是持有锁的线程,status置为0，将锁释放'
    ]}
],
'独享锁VS共享锁':[
    '多线程能不能共享一把锁',
    {'独享锁':[
        '即排他锁，该锁一次只能被一个线程持有',
        '如线程T对数据A加上排它锁后，其他线程不能再对A加任何类型的锁',
        '获得排它锁的线程即能读数据又能修改数据',
        '如JDK中的synchronized和JUC中Lock的实现类'
    ]},
    {'共享锁':[
        '锁可被多线程持有',
        '如线程T对数据A加共享锁后，其他线程也可对A再加共享锁，不能加排它锁',
        '获得共享锁的线程只能读数据，不能修改数据',
        '如ReentrantReadWriteLock'
    ]}
]


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 