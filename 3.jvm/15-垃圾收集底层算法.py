import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("垃圾收集算法")
r2=s2.getRootTopic()
r2.setTitle("垃圾收集算法")


content={
'垃圾收集底层算法实现':[
    {'三色标记':[
        {'黑色':[
            '对象已经被垃圾收集器访问过， 且这个对象的所有引用都已经扫描过',
            ' 它是安全存活的， 如果有其他对象引用指向了黑色对象， 无须重新扫描一遍',
            '黑色对象不可能直接（不经过灰色对象） 指向某个白色对象'
        ]},
        {'灰色':[
            '对象已经被垃圾收集器访问过， 但这个对象上至少存在一个引用还没有被扫描过'
        ]},
        {'白色':[
            '对象尚未被垃圾收集器访问过',
            '在可达性分析刚刚开始的阶段， 所有的对象都是白色的， 若在分析结束的阶段， 仍然是白色的对象，代表不可达'
        ]},
    ]},
    '把Gcroots可达性分析遍历对象过程中遇到的对象， 按照“是否访问过”这个条件标记成三种颜色,最后只回收白色的',
],
'并发过程问题':[
    {'多标-浮动垃圾':[
        {'并发标记':[
            '方法运行结束部分局部变量被销毁',
            '而局部变量引用的对象之前又被扫描过(被标记为非垃圾对象)，本轮GC不会回收这部分内存'
        ]},
        {'并发清理':[
            '并发清理开始后产生的新对象，直接全部当成黑色'
        ]}
    ]},
    {'漏标-读写屏障':[
        {'增量更新':[
            'Incremental Update',
            '黑色对象插入新的指向白色对象的引用时,将这个新插入的引用记录下来',
            '等并发扫描结束后， 将这些记录过的引用关系中的黑色对象为根， 重新扫描一次',
            '即黑色对象一旦新插入了指向白色对象的引用后，它就变回灰色对象',
            {'分析':[
                'CMS对增量引用的根对象会做深度扫描,效率会低一些'
            ]}
        ]},
        {'原始快照':[
            'Snapshot At The Beginning，SATB',
            '当灰色对象要删除指向白色对象的引用关系时，将这个要删除的引用记录下来',
            '等并发扫描结束之后，再将这些记录过的引用关系中的灰色对象为根,重新扫描一次',
            '如能扫描到白色的对象，将白色对象直接标记为黑色',
            {'分析':[
                '可能造成更多的浮动垃圾'
            ]}
        ]},
        {'以Java HotSpot VM为例，其并发标记时对漏标的处理':[
            {'CMS':[
                '写屏障 + 增量更新'
            ]},
            {'G1，Shenandoah':[
                '写屏障 + SATB'
            ]},
            {'ZGC':[
                '读屏障'
            ]}
        ]},
        {'读写屏障作用':[
            {'写屏障':[
                '记录引用关系的插入和删除',
                '记录跨代引用的变化'
            ]},
            {'读屏障':[
                '支持移动对象的并发执行'
            ]}
        ]}
    ]}
]



}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 