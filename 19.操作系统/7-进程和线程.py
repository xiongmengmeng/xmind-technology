import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="操作系统"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("进程和线程")
r2=s2.getRootTopic()
r2.setTitle("进程和线程")


content={
'进程':[
    '对正在运行中的程序的一个抽象',
    '是操作系统中最核心的概念，作系统的其他所有内容都是围绕着进程展开的',
    '是某一类特定活动的总和，它有程序、输入输出以及状态'
],
'进程模型':[
    '实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中',
    '程序运行结束后，其物理程序计数器会是真正的程序计数器，然后再把它放回进程的逻辑计数器中',
    'CPU 会在各个进程之间来回快速切换,每一个核只能一次运行一个线程'
],
'进程的创建':[
    '系统初始化（init）：启动操作系统时，通常会创建若干个进程',
    '正在运行的程序执行了创建进程的系统调用（比如 fork）',
    {'fork':[
        '创建一个与调用进程相关的副本',
        '一个父进程和子进程会有相同的内存映像，相同的环境字符串和相同的打开文件'
    ]}
],
'进程的终止':[
    '正常退出(自愿的):编译器完成了给定程序的编译后，编译器会执行一个系统调用告诉操作系统它完成了工作(exit)',
    '错误退出(自愿的)：比如执行一条不存在的命令，于是编译器就会提醒并退出',
    '严重错误(非自愿的)',
    '被其他进程杀死(非自愿的):某个进程执行系统调用告诉操作系统杀死某个进程(kill)'
],
'UNIX 进程体系':[
    '在 UNIX 中，进程和它的所有子进程以及子进程的子进程共同组成一个进程组',
    '当用户从键盘发出一个信号，该信号被发送给当前与键盘相关的进程组中的所有成员',
    '每个进程可以分别捕获该信号、忽略该信号或采取默认的动作，即被信号 kill 掉',
    '整个操作系统中所有的进程都隶属于一个单个以 init 为根的进程树'
],
'进程状态':[
    '每个进程是一个独立的实体，有其自己的程序计数器和内部状态',
    '运行态:进程实际占用CPU时间片运行时间',
    '就绪态:可运行，但因为其他进程正在运行而处于就绪状态',
    '阻塞态:除非某种外部事件发生，否则进程不能运行'
],
'进程的实现':[
    '操作系统为了执行进程间的切换，会维护着一张表进程表(process table)，每个进程占用一个进程表项',
    {'进程表内容':[
        '进程管理',
        '存储管理',
        '文件管理关'
    ]}
],
'线程':[
    '多线程：共享同一块地址空间和所有可用数据，这是进程所不具备的',
    '线程要比进程更轻量级，由于线程更轻，所以它比进程更容易创建和撤销,在许多系统中，创建一个线程要比创建一个进程快10-100倍',
    '性能方面：如多个线程都是CPU密集型的，并不能获得性能上的增强，但如存在着大量的计算和大量的I/O处理，会加快应用程序的执行速度'
],
'线程系统调用':[
    '从当前的某个单线程开始，线程通过调用一个库函数（比如 thread_create）创建新的线程',
    '当一个线程完成工作后，可通过调用一个函数（如 thread_exit）来退出,紧接着线程消失，状态变为终止，不能再进行调度'
],
'线程实现(三种)':[
    {'在用户空间中实现线程':[
        '把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在',
        {'通用结构':[
            '线程在运行时系统之上运行，运行时系统是管理线程过程的集合',
            '包括前面提到的四个过程：pthread_create,pthread_exit,pthread_join和pthread_yield'
        ]}
    ]},
    {'在内核空间中实现线程':[
        '当某个线程希望创建一个新线程或撤销一个已有线程时，会进行一个系统调用',
        '这个系统调用通过对【线程表】的更新来完成线程创建或销毁工作',
        '内核中的线程表：有每个线程的寄存器、状态和其他信息'
    ]},
    {'在用户和内核空间中混合实现线程':[
        '编程人员可以自由控制用户线程和内核线程的数量，具有很大的灵活度',
        ''
    ]}
],
'进程间通信':[
    {'信号 signal':[
        '信号通过 shell 将任务发送给子进程',
        '进程可以选择它想要处理的信号，进程也可以选择阻止信号',
        {'不能被忽略的两种信息':[
            'SIGSTOP 信号会通知当前正在运行的进程执行关闭操作',
            'SIGKILL 信号会通知当前进程应该被杀死'
        ]},
        '操作系统会中断目标程序的进程来向其发送信号、在任何非原子指令中，执行都可以中断'
    ]},
    {'管道 pipe':[
        '在两个进程之间，可以建立一个通道，一个进程向这个通道里写入字节流，另一个进程从这个管道中读取字节流',
        '管道是同步的，当进程尝试从空管道读取数据时，该进程会被阻塞，直到有可用数据为止',
        'sort <f | head它会创建两个进程，一个是 sort，一个是 head，sort，会在这两个应用程序之间建立一个管道使得 sort 进程的标准输出作为 head 程序的标准输入'
    ]},
    {'共享内存 shared memory':[
        '两个或者多个进程可以访问公共内存空间,一个进程所作的修改可以对另一个进程可见'
    ]},
    {'先入先出队列 FIFO':[
        '命名管道(Named Pipes),与常规管道类似，但有备份文件'
    ]},
    {'消息队列 Message Queue':[
        '描述内核寻址空间内的内部链接列表',
        '可以按几种不同的方式将消息按顺序发送到队列并从队列中检索消息'
    ]},
    {'套接字 Socket':[
        '提供端到端的双相通信',
        '一个套接字可以与一个或多个进程关联,两种模式',
        '一般用于两个进程间的网络通信，网络套接字需来自诸如TCP或UDP等基础协议的支持',
        {'分类':[
            '顺序包套接字(Sequential Packet Socket)',
            '数据报套接字(Datagram Socket)',
            '流式套接字(Stream Socket)',
            '原始套接字(Raw Socket)'
        ]}
    ]}
]
}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 