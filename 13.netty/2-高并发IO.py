import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="netty"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("高并发IO")
r2=s2.getRootTopic()
r2.setTitle("高并发IO")


content={
'IO读写':[
    '会用到底层的read&write两大系统调用',
    {'read系统调用':[
        '把数据从内核缓冲区复制到进程缓冲区'
    ]},
    {'write系统调用':[
        '把数据从进程缓冲区复制到内核缓冲区'
    ]},
    {'同步IO':[
        '用户空间的线程是主动发起IO请求的一方，内核空间是被动接受方'
    ]},
    {'异步IO':[
        '系统内核是主动发起IO请求的一方，用户空间的线程是被动接受方'
    ]},
    {'内存缓冲区':[
        '目的是为了减少频繁地与设备之间的物理交换',
        '外部设备的直接读写，涉及cpu的中断',
        '发生系统中断时，需要保存之前在cpu中的进程数据和状态等信息，而结束中断之后，还需要恢复之前的进程数据和状态等信息'
    ]}
],
'四种主要的IO模型':[
    {'同步阻塞IO（Blocking IO)':[
        {'内核进行IO执行的两个阶段':[
            '等待数据（操作系数将磁盘数据读取到内核）',
            '复制数据（将数据从内核缓冲区读取到用户缓冲区）'
        ]},
        '在内核进行IO执行的两个阶段,用户线程都被阻塞了',
        '特点：高并发场景下，需要大量的线程来维护大量的网络连接，内存、线程切换开销很大']},
    {'同步非阻塞IO（Non-blocking IO)':[
        {'两个步骤':[
            '1.在内核数据没有准备好的阶段，用户线程发起IO请求时，立即返回',
            '2.内核数据到达后，用户线程发起系统调用，用户线程阻塞'
        ]},
        '特点：应用程序的线程需要不断地进行IO系统调用,会占用大量的CPU时间，效率低下']},
    {'IO多路复用（IO Multiplexing）':[
        {'四个步骤':[
            {'1.选择器注册':[
                '将需要read操作的目标socket网络连接，提前注册到select/epoll选择器中，Java中对应的选择器类是Selector类'
            ]},
            {'2.就绪状态的轮询':[
                '通过选择器的查询方法，查询注册过的所有socket连接的就绪状态，内核会返回一个就绪的socket列表'
            ]},
            {'3.用户线程发起read系统调用':[
                '用户线程获得了就绪状态的列表后，根据其中的socket连接，发起read系统调用',
                '用户线程阻塞，内核开始复制数据，将数据从内核缓冲区复制到用户缓冲区'
            ]},
            '4.复制完成后，内核返回结果，用户线程解除阻塞的状态'
        ]},
        {'特点':[
            '涉及两种系统调用（System Call），一种是select/epoll（就绪查询），一种是IO操作',
            '通过select/epoll系统调用，一个进程可以监视多个文件描述符，一旦某个描述符就绪（一般是内核缓冲区可读/可写）',
            '内核能够将就绪的状态返回给应用程序',
            'Java语言的NIO（New IO）技术，使用的就是IO多路复用模型',
            '系统开销小，系统不必为每一个网络连接（文件描述符）创建进程/线程，从而大大减小了系统的开销。'
        ]}
    ],
    '异步IO（Asynchronous IO）':[
        {'四个步骤':[
            '1.用户线程通过系统调用，向内核注册某个IO操作,用户执行后续的业务操作',
            '2.内核进行整个IO操作（包括数据准备、数据复制）',
            '3.完成后，通知用户程序:内核会给用户线程发送一个信号（Signal），或者回调用户线程注册的回调接口',
            '4.用户线程读取用户缓冲区的数据' 
        ]},
        {'特点':[
            '非阻塞：在内核等待数据和复制数据的两个阶段，用户线程都不是阻塞的',
            '信号/事件驱动：用户线程需要接收内核的IO操作完成的事件，或者用户线程需要注册一个IO操作完成的回调函数',
            '内核支持：应用程序仅需要进行事件的注册与接收，其余的工作都留给了操作系统，因此需要底层内核提供支持'
        ]}
    ]},
],
'操作系统对高并发的底层的支持':[
    '在Linux系统中，文件可分为：普通文件、目录文件、链接文件和设备文件',
    '文件句柄，文件描述符（File Descriptor）:内核为了高效管理已被打开的文件所创建的索引',
    '所有的IO系统调用，包括socket的读写调用，都是通过文件描述符完成的',
    'Linux操作系统中文件句柄数的限制，编辑/etc/rc.local开机启动文件:ulimit -SHn 1000000'
]
}


#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 