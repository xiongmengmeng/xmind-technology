import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("GC回收其他")
r2=s2.getRootTopic()
r2.setTitle("GC回收其他")


content={
'四种引用':[
    {'强引用（StronglyReference）':[
        '垃圾收集器永远不会回收掉被引用的对象'
    ]},
    {'软引用（Soft Reference）':[
        '还有用，但非必须的对象',
        '发生内存溢出前，进行回收',
        '对象列进回收范围之中进行第二次回收',
        'SoftReference类来实现'
    ]},
    {'弱引用（Weak Reference）':[
        '非必须对象',
        '弱引用关联的对象只生存到下一次垃圾收集发生为止',
        'WeakReference类来实现',
        'ThreaLocal中的map，继承弱引用WeakReference，防止map中的key引用的对象无法被回收'
    ]},
    {'虚引用（Phantom Reference）':[
        '对象是否有虚引用，不对其生存时间构成影响，不能通过虚引用取得对象实例',
        {'存在目的':[
            '对象被收集器回收时收到一个系统通知'
        ]},
        'PhantomReference类来实现'
    ]}
],
'记忆集与卡表':[
    {'思考':[
        '一个对象被不同区域引用，判断对象存活是否需要扫描整个Java堆'
    ]},
    {'目的':[
        '避免全局扫描，缩短根枚举时间'
    ]},
    {'记忆集':[
        '一种用于记录从【非收集区域指向收集区域指针】集合的抽象数据结构',
        '缩减GC Roots扫描范围',
        {'实现':[
            {'字长精度':[
                '每个记录精确到一个机器字长（处理器的寻址位数，如常见的 32 位或 64 位），该字包含跨代指针'
            ]},
            {'对象精度':[
                '每个记录精确到一个对象，该对象中有字段包含跨代指针'
            ]},
            {'卡精度':[
                '每个记录精确到一块内存区域，该区域中有对象包含跨代指针',
                '使用一种叫做“卡表”的方式实现记忆集,目前最常用的一种记忆集实现形式'
            ]}
        ]},
        '记忆集是一种抽象概念，卡表是它的实现方式',
    ]},
    {'卡页':[
        '每个元素对应着其标识的内存区域一块特定大小的内存块'
    ]},
    {'卡表':[
        '使用一个字节数组实现,每个卡表项对应一个卡页,用于标记卡页的状态',
        '卡页中有一个对象的字段存在着跨代指针，对应卡表的数组元素值标识为1，称元素变脏,没有标识为0',
        '当对一个对象引用进行写操作时（对象引用改变），写屏障逻辑将会标记对象所在的卡页为dirty',
        {'卡表的维护---写屏障':[
            '对引用的更新,会进行一次写屏障操作,写屏障内更新卡表'
        ]},
        {'作用':[
            '垃圾收集发生时，筛选出卡表中变脏的元素，加入GC Roots中一并扫描'
        ]}
    ]}
],
'并行和并发':[
    {'并行':[
        '一个处理器核处理一个任务',
        '同一时间多条垃圾收集器线程协同工作，默认此时用户线程处于等待状态'
    ]},
    {'并发':[
        '一个处理器核处理多个任务',
        '同一时间垃圾收集器线程与用户线程都在运行'
    ]}
]



}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 