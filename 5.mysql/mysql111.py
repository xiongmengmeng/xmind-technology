import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="mysql"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("other")
r2=s2.getRootTopic()
r2.setTitle("other")


content={
'SQL 优化之道':[
    'sql打印出来之后explain看看',
    '查询条件尽量在索引上',
    '避免回表，避免多次回表',
    '排序条件在查询索引上',
    '参与排序的列越少越好，多了就要fileSort',
    'count(*)比其他的快',
    '一张表的索引不能太多',
    '联合索引要考虑最左匹配',
],
'MySQL 遇到的死锁问题':[
    {'事务先更新/删除，然后插入数据，并发会引起间隙锁死锁':[
        '事务A一条删除或更新语句没有执行到数据，加间隙锁',
        '事务B一条删除或更新语句没有执行到数据，加间隙锁，范围相同',
        '事务A的插入语句等待B释放锁',
        '事务B的插入语句等待A释放锁',
        'mysql察觉到死锁，让其中一个回滚，另一个继续执行',
    ]},
    {'RPC中的死锁':[
        '服务1和服务2都需要操作同一个表',
        '服务1开启事务，更新一条数据，RPC调用服务2，等待服务2返回结果',
        '服务2开启事务，更新同一条数据，等待服务1释放锁',
        '服务1等待超时，事务回滚',
        '服务2执行完毕，返回结果，但是RPC已经超时了',
    ]}
],

'数据库索引的原理':[
    '用一些算法和数据结构达到搜索更快的目的',
    '散列表实现索引，直接使用hash搜索',
    '有序线性表实现索引，使用二分法查找',
    'B+树实现索引，按大小遍历到叶子节点',
],

'聚集索引与非聚集索引的区别':[
    '聚集索引的排序方式与数据库中保持一致，非聚集索引则不一致',
    '聚集索引适合范围查询和返回，但是更新的效率慢',
    '非聚集索引适合范围查询，但是不适合范围返回，更新效率更高',
    'innoDB的主键索引是聚集索引，次级索引是非聚集索引，因为叶子节点存储了主键的值，所以要回表查询',
],
'limit 20000 加载很慢怎么解决':[
    '假如你真的需要20000数据，那么只能通过在排序列建立索引，或者把数据导入es，用es搜索引擎查询',
    '假如只是limit 20000,10,那么把20000的值先查出来，作为条件加入到where'
],
'选择合适的分布式主键方案':[
    '通过同一个redis获取自增主键',
    {'按雪花算法':[
        '定义每个分布式服务的每秒钟数据域',
        '比如用10位时间戳，6位的数据域，有10个分布式应用，每个10W个id可以用',
        '可以按业务再分数据域，让每个应用用不同的数据域即可',
        '并且在应用重启时，数据域id同步到zookeeper，避免重启后重复'
    ]}
],

'一张自增表里面总共有7条数据，删除了最后2条数据，重启数据库，在插入一条，此时id是几':[
    'innoDB使用的AUTO_INCREMENT其实是select  max(id) +1 和内存中放好的AUTO_INCREMENT比较',
    '每次得到的id会放置在内存中，不会持久化',
    '所以重启数据库之后，内存中的AUTO_INCREMENT消失，得到的最大id是6'
],
'如何获取当前数据库版本':[
    'mysqladmin --version获取当前安装的数据库版本',
    'rpm -qa | grep mysql查询服务器中mysql安装版本'
],
'ACID是什么':[
    '原子性，一致性，隔离性，持久性',
    '原子性，指操作是不可分割的',
    '一致性，指一起成功，一起失败',
    '隔离性，指不会被其他影响',
    '持久性，指每次操作都是已经执行了，已经持久化到磁盘的',
],
'mysql的内连接，左连接右连接有什区别':[
    'inner交集，left左边表的全集，right右边表的全集，outer并集'
],
'mysql索引是怎么实现的':[
    'B+树实现',
    'innoDB叶子节点主键id，聚集索引存行地址，MyISAM都是存整列数据',
    '非叶子节点存储索引值',
],
'怎么验证 mysql 的索引是否满足需求':[
    'explain查询结果',
    '看rows扫描行数是否太多',
    '看是否使用索引，是否使用了想要的索引',
    '索引长度确定使用了索引中的几个字段',
    {'看extra排序方式':[
        'extra是不是using index，using index condition，索引排序或者索引下推',
        '如果是Using where则表示没有使用索引排序，而是全表扫描',
        'Using temporary排序数量过大使用了临时表',
        'Using filesort无法使用索引，用文件排序'
    ]}
]
'如何做 mysq| 的性能优化?':[
    'explain sql',
    '看情况加索引',
    '排序列在where条件内',
    '扫描行数越少越好',
    '按业务分库，不同的数据库实例执行',
    '太大的表要分库分表'
]





'选择合适的数据存储方案':[
    'mysql，用mysql存储结构化、关联性强，持久化的数据',
    'mongoDB，用MongoDB存储非结构化的，持久化的数据',
    'redis，用redis存储热点、缓存、非持久化得数据',
    'elasticSearch，用es建立海量数据的索引，进行复杂和数据量很大的搜索服务',
],
'mongoDB的ObjectId 规则':[
    'mongo的_id是一个24位16进制字符串，其中包括时间戳，机器hash码，自增id'
],
'聊聊 MongoDB 使用场景':[
    '非结构化数据，如果一个业务每次产生的数据有多种字段，多种结构，那么需要mongo',
    '数组，如果一个数据的结构类型时数组，而且要查a[i]=?的数据，那么需要mongo',
],
'倒排索引':[
    '正排索引指我们为找到关键字在文档、数据表中的位置建立索引，索引的目的是快速在一个确定的文档中找到关键字的位置，在一张确定的表里找到某行数据',
    '倒排索引相反，是为了找到某个文档，由关键字找文档，由某个记录找到所在表',
    '关键字搜索就需要倒排索引，ES就需要倒排索引',
],
'ElasticSearch 使用场景':[
    '数据库有一张几亿数据的表，查询效率极低，但是插入数据不多，导入es中建立索引，每天同步数据建立索引用于查询',
    '数据库中有很多张表需要连表，但是不需要一张大表，连表效率极低，建立包含的数据导入es',
],
}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 