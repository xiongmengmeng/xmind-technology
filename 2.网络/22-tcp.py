import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="internet"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("tcp")
r2=s2.getRootTopic()
r2.setTitle("tcp")


content={
'累计确认(累计应答)':[
    '为保证顺序性，每个包都有一个ID',
    '服务器收到包后，会应答某个ID，表示之前的包都收到了'
],
'发送端':[
    {'发送端的缓存里的ID包，有四种情况':[
        '发送并且确认的',
        '发送尚未确认的',
        '没有发送等待发送的',
        '没有发送并且暂时不会发送的'
    ]},
    '接收端会给发送端报一个窗口大小，叫Advertised window',
    '大小等于第二部分加上第三部分，超过这个窗口，接收端接收不过来，就不能发送了'
],
'接收端':[
    {'':[
        '接收并且确认过的',
        '还没接收，但是马上就能接收的',
        '还没接收，但也无法接收的'
    ]}
],
'关注以下问题':[
    '顺序问题:重发',
    '丢包问题:重发',
    '连接维护',
    {'流量控制':[
        '对于包的确认中，会携带一个窗口的大小'
    ]},
    {'拥塞控制':[
        '调大窗口，使得单位时间可以发送更多的包，结果出现接收端处理不过来，多出来的包会被丢弃',
        '拥塞控制主要来避免两种现象，包丢失和超时重传',
        '解决：将当前传输速率减慢,有慢启动,拥塞避免,拥塞发生,快速恢复等算法'
    ]},
    {'总结':[
        'TCP 的顺序问题，丢包问题，流量控制都是通过滑动窗口来解决的'
        '拥塞控制时通过拥塞窗口来解决的'
    ]}
],
'拆包，粘包':[
    {'出现原因':[
        '1.要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包',
        '2.待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包',
        '3.要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包',
        '4.接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包'
    ]},
    {'解决':[
        '1.发送端给每个数据包添加包首部，首部至少包含数据包的长度，这样接收端在接收到数据后，读取包首部的长度字段，便知道每一个数据包的实际长度',
        '2.发送端将每个数据包封装为固定长度（不够补0填充），接收端每次从接收缓冲区中读取固定长度的数据即可把每个数据包拆分开来',
        '3.可在数据包间设置边界，如添加特殊符号，这样接收端通过边界可将不同的数据包拆分开'
    ]}
]

}


#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 