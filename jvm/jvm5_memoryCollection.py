import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm_memoryCollection")
r2=s2.getRootTopic()
r2.setTitle("jvm_内存回收")


content={
'回收':[
    {'方法或者线程结束，自然回收':[
        '程序计数器',
        '虚拟机栈',
        '本地方法栈'
    ]},
    {'方法区回收':[
        '废弃的常量:没有对象引用时回收',
        {'不再使用的类型':[
            '类所有的实例都已经被回收',
            '加载该类的类加载器已经被回收',
            '类对应的Class对象没有被引用，无法通过反射访问'
        ]},
        '满足条件的类型，只是允许回收，是否能回收看配置'
    ]},
    {'对象回收':[
        {'引用计数法':[
            '对象被引用一次，计数器值+1',
            '引用失效，计数器值-1',
            '计数器为0的对象不再被使用',
            '问题：相互引用'
        ]},
        {'可达性分析法':[
            'GC Roots到对象不可达，对象不再被使用',
            {'GC Roots的对象':[
                '虚拟机栈中引用的对象',
                '方法区中类静态属性引用的对象',
                '方法区中常量引用的对象，如字符串常量池（String Table）里的引用',
                '本地方法栈中JNI（即Native方法）引用的对象',
                {'虚拟机内部的引用':[
                    '基本数据类型对应的Class对象',
                    '常驻异常对象（如NullPointExcepiton）',
                    '系统类加载器'
                ]},
                '同步锁（synchronized关键字）持有的对象',
                '反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存'
            ]}
        ]},
        {'四种引用':[
            {'强引用（StronglyReference）':[
                '垃圾收集器永远不会回收掉被引用的对象'
            ]},
            {'软引用（Soft Reference）':[
                '还有用，但非必须的对象',
                '发生内存溢出前，进行回收',
                '对象列进回收范围之中进行第二次回收',
                'SoftReference类来实现'
            ]},
            {'弱引用（Weak Reference）':[
                '非必须对象',
                '弱引用关联的对象只生存到下一次垃圾收集发生为止',
                'WeakReference类来实现',
                'ThreaLocal中的map，继承弱引用WeakReference，防止map中的key引用的对象无法被回收'
            ]},
            {'虚引用（Phantom Reference）':[
                '对象是否有虚引用，不对其生存时间构成影响，不能通过虚引用取得对象实例',
                '存在目的：对象被收集器回收时收到一个系统通知',
                'PhantomReference类来实现'
            ]}
        ]},
        {'宣告一个对象死亡':[
            '1.标记GC Roots不可达对象',
            '2.筛选对象是否可执行finalize()方法，将对象放置在F-Queue的队列中',
            '3.由低调度优先级的Finalizer线程去执行它们的finalize()方法',
            '4.收集器将对F-Queue中的对象进行第二次小规模的标记',
            '注：finalize()是对象逃脱死亡命运的最后一次机会'
        ]}
    ]}
],
'专业名词':[
    {'根节点枚举':[
        'HotSpot使用一组称为OopMap的数据结构',
        '类加载完成时:把对象内什么偏移量上是什么类型的数据计算出来',
        '即时编译过程中:在特定的位置记录下栈里和寄存器里哪些位置是引用'
    ]},
    {'安全点:GC时机':[
        '以“是否具有让程序长时间执行的特征”为原则进行选定',
        '方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点',
        '可数循环:使用int类型或范围更小的数据类型作为索引值的循环',
        '不可数循环：使用long或者范围更大的数据类型作为索引值的循环',
        '虚拟机为了避免安全点过多，对循环做了优化，不可数循环才会被放置安全点',
        {'两种方案':[
            {'抢先式中断':[
                '所有用户线程都中断',
                '如有用户线程中断不在安全点上，恢复线程，跑到安全点上再中断'
            ]},
            {'主动式中断':{
                '设一个标志位，线程执行过程不断轮询，标志为真自己在最近安全点中断挂起',
                '轮询标志的地方和安全点是重合的'
            }}
        ]},
    ]},
    {'安全区域':[
        '确保在某一段代码片段之中，引用关系不会发生变化'
    ]},
    {'记忆集与卡表':[
        {'记忆集':[
            '一种用于记录从非收集区域指向收集区域指针集合的抽象数据结构',
            '缩减GC Roots扫描范围'
        ]},
        {'卡精度':[
            '每个记录精确到一块内存区域，该区域内有对象含有跨代指针',
            '目前最常用的一种记忆集实现形式'
        ]},
        '卡页中有一个对象的字段存在着跨代指针，对应卡表的数组元素值标识为1，称元素变脏,没有标识为0',
        '垃圾收集发生时，筛选出卡表中变脏的元素，加入GC Roots中一并扫描',
        {'写屏障':[
            '维护卡表状态'
        ]}
    ]},
    {'并行':[
        '一个处理器核处理一个任务',
        '同一时间多条垃圾收集器线程协同工作，默认此时用户线程处于等待状态'
    ]},
    {'并发':[
        '一个处理器核处理多个任务',
        '同一时间垃圾收集器线程与用户线程都在运行'
    ]}
],
'垃圾收集算法':[
    {'名词定义':[
        '部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集',
        '新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集',
        '老年代收集（Major GC/Old GC）：只是老年代的垃圾收集(CMS收集器)',
        '混合收集（Mixed GC）：整个新生代以及部分老年代的垃圾收集(G1收集器)',
        '整堆收集（Full GC）：整个Java堆和方法区的垃圾收集'
    ]},
    {'标记-清除算法':[
        '标记和清除都需要进行遍历，效率低',
        {'缺点':[
            '执行效率不稳定',
            '内存碎片化,用“分区空闲分配链表”解决内存分配问题，程序吞吐量下降'
        ]}
    ]},
    {'标记-复制算法':[
        '适用于新生代，每次GC存活对象少',
        '一块Eden，两块较小的Survivor，比例8：1',
        {'过程':[
            '垃圾收集',
            '将Eden和Survivor中存活的对象复制到另外的Survivor上',
            '清理掉Eden和用过的那块Survivor空间'
        ]},
        'Survivor空间不足时，依赖其他内存区域（大多是老年代）进行分配担保'
    ]},
    {'标记-整理算法':[
        '将存活对象向内存一端移动，然后清理掉边界以外的内存',
        {'缺点':[
            '停顿时间长，移动存活对象会更新所有引用这些对象的地方'
        ]}
    ]}
]

}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 