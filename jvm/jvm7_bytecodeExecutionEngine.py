import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm_bytecodeExecutionEngine")
r2=s2.getRootTopic()
r2.setTitle("jvm_字节码执行引擎")


content={
'Java虚拟机的执行引擎':[
    '输入的是字节码文件',
    '处理过程是字节码解析的过程',
    '输出的是执行结果'
],
'栈帧':[
    {'背景':[
        'Java虚拟机以方法作为最基本的执行单元',
    ]},
    {'目的':[
        '支持虚拟机进行方法调用和方法执行'
    ]},
    {'内容':[
        {'局部变量表':[
            '一组变量值的存储空间，单位：变量槽',
            '存放方法参数和方法内部定义的局部变量',
            {'方法被调用时':[
                '虚拟机会使用局部变量表来完成实参到形参的传递',
                '即参数值到参数变量列表的传递过程'
            ]},
            {'实例方法被调用':[
                '第0位变量槽默认传递方法所属对象实例的引用',
                '方法中可通过this来访问这个隐含的参数',
                '其余参数按照参数表顺序排列，占用从1开始的变量槽',
                '参数分配完，据方法体内部定义变量顺序和作用域分配其余变量槽'
            ]},
            {'注意':[
                '局部变量要赋初始值',
                '类变量不需要，因为它在<准备阶段>会赋默认值'
            ]} 
        ]},
        {'操作数栈':[
            '最大深度编译时确认，存在Code属性的max_stacks数据项'
        ]},
        {'栈帧间的数据共享':[
            '下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠',
            '节约空间，方法调用时直接共用部分数据，无须进行额外的参数复制',
        ]},
        {'动态连接':[
            '运行期间将符号引用->直接引用'
        ]},
        {'方法返回地址':[
            '正常调用完成：执行引擎遇到一个方法返回的字节码指令',
            '方法执行过程遇异常，且异常没有在方法体内处理'
        ]}
    ]}
],
'动态类型语言':[
    {'关键特征':[
        '类型检查的主体过程是在【运行期】而不是编译期进行的',
        '变量无类型而变量值才有类型'
    ]},
    {'Java与动态类型':[
        '之前：单纯依靠符号引用来确定调用的目标方法',
        'java.lang.invoke包:提供一种新的动态确定目标方法的机制(方法句柄)'
    ]},
    {'invokedynamic指令':[
        {'动态调用点':[
            '每一处含有invokedynamic指令的位置'
        ]},
        'CONSTANT_InvokeDynamic_info常量',
        {'常量细节':[
            {'引导方法':[
                '存放在新增的BootstrapMethods属性中，有固定的参数',
                '返回值是java.lang.invoke.CallSite对象,代表真正要执行的目标方法',
                '据常量中的信息，虚拟机可找到并执行引导方法，获得一个CallSite对象',
                '通过CallSite对象，最终调用到要执行的目标方法'
            ]},
            '方法类型',
            '名称'
        ]},
        '不再是代表方法符号引用的CONSTANT_Methodref_info常量'
      
    ]}
],
'基于栈的字节码解释执行引擎':[
    {'虚拟机执行方法里字节码指令':[
        {'解释执行':[
            '总：通过解释器执行',
            '通过JVM将源代码字节码编译成JVM解释器可识别的虚拟机指令',
            '然后虚拟机将这些指令和底层的操作系统以及硬件对应起来'
        ]},
        {'编译执行':[
            '总：通过即时编译器产生本地代码执行',
            '直接将源代码编译成机器码',
            '机器可以直接执行',
            '运行时，多针对热点代码'
        ]}
    ]},
    {'编译过程':[
        '1.程序源码->词法分析->语法分析->抽象语法树',
        '2.抽象语法树->指令流（可选）->解释器->解释执行',
        '3.抽象语法树->优化器（可选）->中间代码（可选）->生成器->目标代码'
    ]},
    {'Javac编译器':[
        '程序编译：程序代码->词法分析->语法分析->抽象语法树->遍历语法树->线性字节码指令流',
        '上述都在Java虚拟机之外进行，而解释器在虚拟机内部，所以Java程序的编译是半独立'
    ]},
    {'基于栈和基于寄存器的指令集':[
        '栈结构指令集：字节码指令流里指令大部分是零地址指令，依赖操作数栈工作',
        '整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径',
        '寄存器的指令集:依赖寄存器进行工作'
    ]}
]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 