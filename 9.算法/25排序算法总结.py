import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="算法"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("排序算法总结")
r2=s2.getRootTopic()
r2.setTitle("排序算法总结")


content={
'比较器':[
    {'实质':[
        '重载比较运算符'
    ]},
    '可以很好的应用在特殊标准的排序上',
    '可以很好的应用在特殊标准排序的结构上',
    '写代码变得异常容易，还用于范型编程',
    {'comp(o1,o2)':[
        '返回负：第一个参数排在前，如o1小，升序',
        '返回0：相等',
        '返回正：第二个参数排在前，如o1小，降序'
    ]},
    {'实现':[
        {'Comparator<T>':[
            '重写方法compart(T t1,T t2)',
            '实现return t1-t2,默认升序',
            '实现return t1.age!=t2.age?(t1.age-t2.age):(t1.id-t2.id):先按年龄升序，年龄相同，再按id升序'
        ]}
    ]}
],
'排序算法的稳定性':[
    {'稳定性':[
        '同样大小的样本再排序之后不会改变相对次序'
    ]},
    '对基础类型来说，稳定性无意义',
    '对非基础类型来说，稳定性有重要意义',
    '有些排序算法可以实现成稳定的，而有些排序算法无论如何 都实现不成稳定的'
],
'排序算法总结':[
    '1.不基于比较的排序,对样本数据有严格要求,不易改写',
    '2.基于比较的排序,只要规定好两个样本怎么比大小就可以直接复用',
    '3.基于比较的排序,时间复杂度的极限是O(N*logN)',
    '4.时间复杂度的极限是O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的',
    '5.为了绝对的速度先快排、为了省空间选堆排、为了稳定选归并'
],
'常见坑':[
    '1.归并排序的额外空间复杂度可变成O(1)归并排序内部缓存法，但是将变得不再稳定,不图稳定,直接用堆就好了',
    '2."原地归并排序"是虽让额外空间复杂度变为O(1)，但会让时间复杂度变成O(N^2)',
    '3.快速排序稳定性改进,但是会对样本数据要求更多',
    '4.整型数组中,请把奇数放在数组左边，偶数放在数组右边，要求奇数和偶数间原始的相对次序不变',
    '同时时间复杂度为O(N),额外空间复杂度为O(1),不可能'
],
'工程上对排序的改进':[
    {'1.稳定性的考虑':[
        'Arrays.sort():',
        '1.反射判断变量是否为基础类型，是，快排',
        '2.不是:归并排序'
    ]},
    {'2.充分复用O(N*log^N)和O(N^2)排序的各自优势 ':[
        '数据量小于60时，用插入排序，N小，其常数项也小，快',
        '数据量大于60时，用快速排序，利用其调度优势，快'
    ]}
]


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 