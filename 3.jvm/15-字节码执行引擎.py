import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("字节码执行引擎")
r2=s2.getRootTopic()
r2.setTitle("字节码执行引擎")


content={
'动态类型语言':[
    {'关键特征':[
        '类型检查的主体过程是在【运行期】而不是编译期进行的',
        '变量无类型而变量值才有类型'
    ]},
    {'Java与动态类型':[
        '之前：单纯依靠符号引用来确定调用的目标方法',
        'java.lang.invoke包:提供一种新的动态确定目标方法的机制(方法句柄)'
    ]},
    {'invokedynamic指令':[
        {'动态调用点':[
            '每一处含有invokedynamic指令的位置'
        ]},
        'CONSTANT_InvokeDynamic_info常量',
        {'常量细节':[
            {'引导方法':[
                '存放在新增的BootstrapMethods属性中，有固定的参数',
                '返回值是java.lang.invoke.CallSite对象,代表真正要执行的目标方法',
                '据常量中的信息，虚拟机可找到并执行引导方法，获得一个CallSite对象',
                '通过CallSite对象，最终调用到要执行的目标方法'
            ]},
            '方法类型',
            '名称'
        ]},
        '不再是代表方法符号引用的CONSTANT_Methodref_info常量'
      
    ]}
],
# 'Java虚拟机的执行引擎':[
#     {'输入':[
#         '字节码文件'
#     ]},
#     {'处理过程':[
#         '字节码解析过程'
#     ]},
#     {'输出':[
#         '执行结果'
#     ]},
# ],
'基于栈的字节码解释执行引擎':[
    'Java【编译期】输出的指令流，是【基于栈】的【字节码指令集合】架构',
    {'虚拟机执行方法里字节码指令':[
        {'解释执行---通过解释器执行':[
            '通过【JVM】将【源代码字节码】编译成【JVM解释器】可识别的【虚拟机指令】',
            '然后虚拟机将这些【指令】和【底层的操作系统以及硬件】对应起来'
        ]},
        {'编译执行---通过即时编译器产生本地代码执行':[
            '直接将【源代码】编译成【机器码】',
            '机器可以直接执行',
            '运行时，多针对热点代码'
        ]}
    ]},
    {'编译过程':[
        '1.程序源码->词法分析->语法分析->抽象语法树',
        '2.抽象语法树->指令流（可选）->解释器->解释执行',
        '3.抽象语法树->优化器（可选）->中间代码（可选）->生成器->目标代码'
    ]},
    {'Javac编译器':[
        {'程序编译':[
            '程序代码->词法分析->语法分析->抽象语法树->遍历语法树->线性字节码指令流'
        ]},
        '上述都在Java虚拟机之外进行，而解释器在虚拟机内部，所以Java程序的编译是半独立'
    ]},
    {'基于栈和基于寄存器的指令集':[
        {'栈结构指令集':[
            '字节码指令流里指令大部分是零地址指令，依赖操作数栈工作'
        ]},
        '整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径',
        {'寄存器的指令集':[
            '依赖寄存器进行工作'
        ]}
    ]}
]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 