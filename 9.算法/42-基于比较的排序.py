import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="算法"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("基于比较的排序算法")
r2=s2.getRootTopic()
r2.setTitle("基于比较的排序算法")


content={
'冒泡排序':[
    '1.从数组右边开始比较相邻两个数据的大小',
    '2.左边数据大,交换两个数据的位置',
    '3.左边数据小,移动到下一位置,循环2-3的操作，直到数组末,数组最后一个数据为最大值',
    '4.循环1-3的过程，直接数组首部的元素被确定下来',
    {'时间复杂度':[
        'O(n^2)',
        '总的比较次数为(n-1)+(n-2)+…+1≈n^2/2'
    ]}
],
'选择排序':[
    {'1.将数组分为两部分,已排序与待排序两区域':[
        {'已排序':[
            '为排序好的区域(整体看是排序好的),初始只有最左侧的一个数据'
        ]},
        {'待排序':[
            '初始为除数组第一个元素的其余数据'
        ]}
    ]},
    '2.从待排序的数组中寻找最小值，将其与序列最左边的数据进行交换',
    '3.循环2的过程，直接待排序数组为空',
    {'时间复杂度':[
        'O(n^2)',
        '总的比较次数为(n-1)+(n-2)+…+1≈n^2/2'
    ]}
],
'插入排序':[
    {'1.将数组分为两部分,左右两区域':[
        {'左侧区域':[
            '为排序好的区域(内部是排序好的),初始只有最左侧的一个数据'
        ]},
        {'右侧区域':[
            '初始为除数组第一个元素的其余数据'
        ]}
    ]},
    '2.按顺序从右侧的未排序区域内取出一个数据k',
    {'3.将它与左边的数据比较':[
        {'左边数据小':[
            '将数据加入左侧区域,本轮操作结束'
        ]},
        {'左边数据大':[
            '将数据加入左侧区域,交换两个数据的位置',
            '数据k继续与左边数据比较,循环3的过程，直接到k到达序列最左端'
        ]}
    ]},
    '4.循环2-3的过程，直接右侧未排序区域为空',
    {'时间复杂度':[
        'O(n^2)'
    ]}
],
'归并排序':[
    '把序列分成长度相同的两个子序列，无法继续往下分时，对子序列进行归并',
    {'归并':[
        '从首位开始,重复比较子序列数据大小->移动较小的数据到数组',
        '花费时间为子序列的总长度，每行O(N)',
    ]},
    {'时间复杂度':[
        'O(N*logN),总行数为logN行'
    ]}
],
'快速排序':[
    '1.在序列中随机选择一个基准值',
    '2.将除基准值以外的数分为“比基准值小的数”和“比基准值大的数”',
    {'3.遍历行中每个数,将其与基准值比较':[
        '如数据比基准值小,将其放到“比基准值小的数”中去',
        '如数据比基准值大,将其放到“比基准值大的数”中去',
    ]},
    '4.在“比基准值小的数”和“比基准值大的数”的数组中,循环1-4的过程,直到数组长度小于2',
    {'时间复杂度':[
        'O(N*logN),总行数为logN行'
    ]}
],
'堆排序':[
    '1.将数组构建成最小堆',
    '2.取出堆中的最小值，将其放于新数组',
    '3.将数组最末的元素放入首个元素的位置，进行heapify,将数组调整成新的最小堆',
    '4.重复2-3的过程，直到从堆中取出所有元素',
    {'时间复杂度':[
        'O(N*logN),总行数为logN行',
        {'每轮取出最大的数据并重构堆':[
            'O(NlogN)'
        ]}
    ]}
],


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 