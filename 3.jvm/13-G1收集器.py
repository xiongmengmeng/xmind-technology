import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("G1收集器")
r2=s2.getRootTopic()
r2.setTitle("G1收集器")


content={
'简介':[
    'Garbage First收集器',
    {'目的':[
        '为了适应现在不断扩大的内存和不断增加的处理器数量'
    ]},
    {'作用':[
        '在延迟可控的情况下获得尽可能高的吞吐量'
    ]},
    {'内存布局':[
        '将Java堆划分为多个大小相等的独立区域',
        '每个Region可扮演新生代的Eden空间、Survivor空间，老年代空间',
        '每个Region都是通过指针碰撞来分配空间',
        {'Region大小':[
            '-XX：G1HeapRegionSize，取值范围为1MB～32MB，为2的N次幂'
        ]},
        {'收集停顿时间':[
            '-XX：MaxGCPauseMillis，默认值是200毫秒'
        ]}
    ]},
    {'大对象存放':[
        'Region有特殊的Humongous区域：用来存储大对象（超过Region容量一半的对象）',
        '超过整个Region容量的大对象，放在N个连续的Humongous Region之中,作为老年代的一部分'
    ]},
    {'优先列表':[
        '每次根据允许的收集时间，优先回收价值最大的Region',
        '保证了G1收集器在有限的时间内可以获取尽可能高的收集效率'
    ]},
    {'回收算法':[
        '内存的回收是以region作为基本单位的',
        'Region之间是复制算法，但整体上实际可看作是标记-压缩（Mark-Compact）算法'
    ]},
    {'G1收集器的常见操作步骤':[
        '1.开启G1垃圾收集器',
        '2.设置堆的最大内存',
        '3.设置最大的停顿时间'
    ]} 
],
'G1回收过程':[
    'JVM启动时，G1先准备好Eden区，程序在运行过程中不断创建对象到Eden区',
    {'Eden耗尽时，触发一次YGC':[
        'Stop-The-World',
        'G1创建回收集(需要被回收的内存分段的集合),集包含年轻代Eden区和Survivor区所有的内存分段',
        {'过程':[
            {'1.扫描根':[
                '根引用连同RSet记录的外部引用作为扫描存活对象的入口'
            ]},
            {'2.更新RSet':[
                '处理dirty card queue（脏卡表）中的 card，更新 RSet',
                '此阶段后，RSet可以准确的反映老年代对所在的内存分段中对象的引用'
            ]},
            {'3.处理RSet':[
                '识别被老年代对象指向的Eden中的对象'
            ]},
            {'4.复制对象':[
                '对象树被遍历，Eden区内存段中存活的对象会被复制到Survivor区中空的内存分段',
                'Survivor区内存段中存活的对象如年龄未达阈值，年龄加1，达到阀值被复制到old区中空的内存分段',
                '如Survivor空间不够，Eden空间的部分数据会直接晋升到老年代空间'
            ]},
            {'5.处理引用':[
                '处理Soft，Weak，Phantom，Final，JNI Weak 等引用',
            ]}
        ]}
    ]},
    {'并发标记':[
        {'1.初始标记阶段':[
            '标记从根节点直接可达的对象,STW,会触发一次年轻代GC',
        ]},
        {'2.根区域扫描':[
            '扫描 Survivor区 直接可达的老年代区域对象，并标记被引用的对象'
        ]},
        {'3.并发标记':[
            '整个堆中进行并发标记，可能被YoungGC中断',
            '过程若发现区域对象中的所有对象都是垃圾，那这个区域会被立即回收（实时回收）',
            '过程会计算每个区域的对象活性（区域中存活对象的比例），用来判断该区域值不值得回收'
        ]},
        {'4.再次标记':[
            '由于应用程序持续进行，需要修正上一次的标记结果。是STW的'
        ]},
        {'5.独占清理':[
            '计算各个区域的存活对象和GC回收比例,并进行排序，识别可以混合回收的区域,是STW'
        ]},
        {'6.并发清理':[
            '识别并清理完全空闲的区域'
        ]}
    ]},
    {'混合回收':[
        '回收整个Young Region，还会回收一部分的Old Region'
    ]},
    {'Full GC':[
        {'条件':[
            '回收的时候没有足够的to-space来存放晋升的对象'
            '并发处理过程完成之前空间耗尽'
        ]}

    ]}
],
'四个步骤':[
    {'初始标记':[
        '标记一下GC Roots能直接关联到的对象',
        '修改TAMS指针的值',
        '需要停顿线程，但耗时很短'
    ]},
    {'并发标记':[
        '从GC Root开始对堆中对象进行可达性分析',
        '递归扫描整个堆里的对象图，找出回收对象，耗时长',
        '可与用户程序并发执行',
        '要重新处理SATB记录下的在并发时有引用变动的对象'
    ]},
    {'最终标记':[
        '需停顿线程',
        '处理并发阶段结束后遗留下来的少量SATB记录'
    ]},
    {'筛选回收':[
        '更新Region统计数据，对各个Region的回收价值和成本进行排序',
        '自由选择任意多个Region构成回收集',
        '把回收Region的存活对象复制到空的Region中',
        '清理掉整个旧Region空间',
        '存活对象的移动，须暂停用户线程'
    ]},
    {'理念':[
        '应付应用的内存分配速率，不追求一次把整个Java堆全部清理干净'
    ]}
],
'与CMS对比':[
    {'G1优点':[
        {'指定最大停顿时间':[
            '相比于CMS GC，G1未必能做到CMS在最好情况下的延时停顿，但是最差情况要好很多'
        ]},
        '分Region的内存布局、按收益动态确定回收集',
        '标记-复制算法'
    ]},
    {'G1缺点':[
        '内存占用,程序运行时的额外执行负载都要比CMS要高'
    ]}
],
'回收过程':[
    {'三个环节':[
        {'年轻代GC（Young GC）':[
            '当年轻代的Eden区用尽时开始年轻代回收过程',
            '收集过程是一个并行的独占式收集器(暂停所有应用程序线程，启动多线程执行年轻代回收)'
        ]},
        {'老年代并发标记过程（Concurrent Marking）':[
            '当堆内存使用达到一定值（默认45%）时,开始老年代并发标记过程,标记完成马上开始混合回收过程',
            
        ]},
        {'混合回收（Mixed GC）':[
            '涉及到老年代和年轻代的混合回收',
            '一次只需要扫描/回收一小部分老年代的Region'
        ]},
        {'备注':[
            '如需要，单线程、独占式、高强度的FullGC是继续存在的',
            '它针对GC的评估失败提供了一种失败保护机制，即强力回收'
        ]}     
    ]},
    '按Young GC->Young GC+Concurrent Mark->Mixed GC顺序,进行垃圾回收,如全满了,执行Full GC',
    {'例子':[
        '一个Web服务器，Java进程最大堆内存为4G，每分钟响应1500个请求，每45秒钟会新分配大约2G的内存',
        'G1会每45秒钟进行一次年轻代回收',
        '每31个小时整个堆的使用率会达到45%，会开始老年代并发标记过程，标记完成后开始四到五次的混合回收'
    ]}
],
'Remembered Set（记忆集）':[
    {'思考':[
        '断对象存活时，是否需扫描整个Java堆才能保证准确,如堆空间比大，扫描开销是否会很大?'
    ]},
    {'解决问题':[
        '一个对象被不同区域引用',
    ]},
    {'记忆集->免全局扫描':[
        '每个Region都有一个对应的Remembered Set',
        '1.每次Reference类型数据写操作时，会产生一个Write Barrier（写屏障）暂时中断这个操作',
        '2.检查【引用该Reference的对象】是否和该Reference类型数据在不同的Region（其他收集器：检查老年代对象是否引用了新生代对象）',
        '3.如相同的，可不记录',
        '4.如不同，通过CardTable（卡表）把相关引用信息记录到【引用该Reference的对象】所在Region对应的Remembered Set 中',
        '5.进行垃圾收集时，在GC根节点的枚举范围加入Remembered Set',
        '6.如此，可保证不进行全局扫描，也不会有遗漏'
    ]}
]

'Java不同版本新特性':[
    {'语法层面':[
        'Lambda表达式、switch、自动拆箱装箱、enum、泛型等'
    ]},
    {'API层面':[
        'Stream API、新的日期时间、Optional、String、集合框架'
    ]},
    {'底层优化':[
        'JVM优化、GC的变化、元空间、静态域、字符串常量池位置变化'
    ]}
]
}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 