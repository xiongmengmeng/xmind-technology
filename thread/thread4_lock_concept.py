import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="thread"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("lock_base")
r2=s2.getRootTopic()
r2.setTitle("锁分类")


content={
'乐观锁/悲观锁':[
    '线程要不要锁住同步资源',
    '悲观锁:适写操作多场景,在Java中使用，是利用各种锁',
    '乐观锁,适读操作多场景,在Java中使用，是无锁编程，常用CAS算法'
],
'伪共享':[
    '缓存系统中是以缓存行(cache line)为单位存储的',
    '当多线程修改互相独立的变量时,如果这些变量共享同一个缓存行',
    '就会无意中影响彼此的性能(番发送RFO消息，占得缓存行的拥有权)',
    {'避免':[
        '缓存填充：让不同线程操作的对象处于不同的缓存行',
        '使用编译指示，强制使每一个变量对齐'
    ]}
],
'偏向锁/轻量级锁/重量级锁':[
    '偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作',
    '轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能',
    '重量级锁是将除了拥有锁的线程以外的线程都阻塞'
],
'自旋锁VS适应性自旋锁 ':[
    {'自旋锁':[
        {'适用':[
            '线程挂起和恢复现场的时长>用户代码执行时长'
        ]},
        {'评价':[
            '避免线程切换开销',
            '但占用处理器时间',
            '使用CPU时间换取线程阻塞与调度的开销'
        ]},
        '自旋等待时间要有限度，没有成功获得锁，应当挂起线程',
        'do-while循环就是一个自旋操作',
        {'三种常见的锁形式':[
            'TicketLock',
            'CLHlock',
            'MCSlock'
        ]}
    ]},
    {'适应性自旋锁':[
        '自旋时间或次数不固定:由前一次在同一个锁上的自旋时间及锁拥有者的状态决定',
        {'情况1':[
            '如在同一个锁对象上',
            '自旋等待刚成功获得过锁，并且持有锁的线程正在运行中',
            '虚拟机认为这次自旋很有可能成功',
            '进而允许自旋等待更长时间'
        ]},
        {'情况2':[
            '如某个锁自旋很少成功获得过',
            '以后尝试获取这个锁将省略自旋',
            '直接阻塞线程，避免浪费处理器资源'
        ]}

    ]}
],
'公平锁VS非公平锁':[
    '多线程竞争锁时要不要排队',
    {'公平锁':[
        '通过同步队列实现多线程按照申请锁的顺序来获取锁，实现公平特性',
        '优点:等待锁的线程不会饿死',
        '缺点:整体吞吐效率比非公平锁低，CPU唤醒阻塞线程的开销比非公平锁大'
    ]},
    {'非公平锁':[
        '多线程直接尝试获取锁，如锁刚好可用，线程获取到锁，否则到队列的队尾等待',
        '优点:减少唤起线程的开销，整体的吞吐效率高，因线程有几率不阻塞直接获得锁',
        '缺点:处于等待队列中的线程可能会饿死，或等很久才会获得锁'
    ]}
],
'可重入锁VS非可重入锁':[
    '一个线程在多个流程能不能获得同一把锁',
    {'可重入锁':[
        'Java中ReentrantLock和synchronized',
        '优点：一定程度避免死锁',
        'AQS中维护了一个同步状态status来计数重入次数'
    ]},
    {'获取锁':[
        {'可重入锁':[
            '尝试获取并更新status值',
            '如status==0，CAS把status置为1，当前线程开始执行',
            '如status!=0，判断当前线程是否是获取到这个锁的线程，如是执行status+1'
        ]},
        '非可重入锁:直接去获取并尝试更新status，如status!=0获取锁失败，当前线程阻塞'
    ]},
    {'释放锁':[
        {'可重入锁':[
            '当前线程是持有锁的线程&&status-1==0',
            'status置为0,将锁释放'
        ]},
        '非可重入锁:当前线程是持有锁的线程,status置为0，将锁释放'
    ]}
],
'独享锁VS共享锁':[
    '多线程能不能共享一把锁',
    {'独享锁':[
        '即排他锁，该锁一次只能被一个线程持有',
        '如线程T对数据A加上排它锁后，其他线程不能再对A加任何类型的锁',
        '获得排它锁的线程即能读数据又能修改数据',
        '如JDK中的synchronized和JUC中Lock的实现类'
    ]},
    {'共享锁':[
        '锁可被多线程持有',
        '如线程T对数据A加共享锁后，其他线程也可对A再加共享锁，不能加排它锁',
        '获得共享锁的线程只能读数据，不能修改数据',
        '如ReentrantReadWriteLock'
    ]}
]


}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 