import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm")
r2=s2.getRootTopic()
r2.setTitle("jvm")


content={
'1.Java技术体系':[
    {'JDK（JavaDevelopment Kit）':[
        {'三部分':[
            'Java程序设计语言',
            'Java虚拟机',
            'Java类库'   
        ]},
        '支持Java程序开发的最小环境',
        'OpenJDK：Sun公司在2006年年末把Java开源而形成的项目',
        {'新版JDK特性':[
            'JDK 9，开放了Java语言级别的编译器接口（JVMCI），使得在Java虚拟机外部增加、替换即时编译器成为可能',
            'JDK 10，重构了Java虚拟机的垃圾收集器接口，统一了其内部各款垃圾收集器的公共行为'
        ]}
    ]},
    {'JRE（Java RuntimeEnvironment）':[
        {'两部分':[
            'Java类库API中的Java SE API子集',
            'Java虚拟机'
        ]},
        '支持Java程序运行的标准环境'
    ]},
    {'高性能Java虚拟机':[
        'HotSpot',
        'JRockit',
        'J9'
    ]}
],
'2.Java内存区域及虚拟机对象':[
    {'运行时数据区域':[
        {'程序计数器':[
            '当前线程 所执行字节码的 行号指示器',
            '线程私有:方便线程切换后恢复到正确的执行位置',
            {'值':[
                '执行一个Java方法：记录正在执行的虚拟机字节码指令的地址',
                '执行本地方法：值为空'
            ]},
            '唯一一个没有规定任何OutOfMemoryError情况的区域'
        ]},
        {'Java虚拟机栈':[
            '线程私有',
            '方法被调->执行完毕，对应一个栈帧在虚拟机栈的入栈与出栈',
            '栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息',
            '栈通常指虚拟机栈，或者指虚拟机栈中局部变量表'
        ]},
        {'本地方法栈':[
            '为本地方法服务'
        ]},
        {'Java堆':[
            '线程共享',
            '几乎所有对象实例都在这里分配内存',
            '特例：栈上分配、标量替换'
        ]},
        {'方法区':[
            '线程共享',
            '存储类型信息、常量、静态变量、即时编译器编译后的代码缓存等',
            '其内存回收目标：常量池的回收和对类型的卸载',
            {'运行时常量池':[
                'Class文件有类的版本、字段、方法、接口等描述信息和常量池表',
                '常量池表:存放编译期生成的各种字面量与符号引用',
                '具备动态性'
            ]},
        ]},
        {'直接内存':[
            'NIO类，一种基于通道与缓冲区的I/O方式，Native函数库直接分配堆外内存',
            '通过一个Java堆里面的DirectByteBuffer对象作为这块内存的引用',
            '避免Java堆和Native堆来回复制数据，提高性能'
        ]}
    ]},
    {'对象':[
        {'对象创建':[
            {'1.类加载检查':[
                '检查指令参数能否在常量池中定位到一个类的符号引用',
                '检查符号引用代表的类是否已被加载、解析和初始化过'
            ]},
            {'2.分配内存':[
                '内存的大小类加载后可完全确定',
                {'内存分配方式':[
                    '由垃圾收集器是否带有空间压缩整理的能力决定',
                    '内存绝对规整:指针碰撞',
                    '内存不规整:空闲列表'
                ]},
                {'并发分配内存的解决方案':[
                    'CAS+失败重试',
                    '本地线程分配缓冲'
                ]},
                '分配到的内存空间（但不包括对象头）都初始化为零值'
            ]},
            '3.填充额外信息到对象头',
            '4.对象初始化，执行<init>()方法'
        ]},
        {'对象内存布局':[
            {'三部分':[
                '对象头（Header）',
                '实例数据（Instance Data）',
                '对齐填充（Padding）'
            ]},
            {'对象头':[
                '1.存储对象自身的运行时数据',
                '如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁等',
                '2.类型指针，即对象指向它的类型元数据的指针',
                '可以没有'
            ]}
        ]},
        {'对象访问定位':[
            '通过栈上的reference数据来操作堆上的具体对象',
            {'两种方式':[
                {'句柄访问':[
                    'Java堆中划分出一块内存来作为句柄池',
                    'reference中存储对象的句柄地址',
                    {'句柄包含':[
                        '对象实例数据的地址信息',
                        '类型数据的地址信息'
                    ]},
                    {'优势':[
                        'reference中存储的是稳定句柄地址',
                        '对象被移动时只会改变句柄中的实例数据指针'
                    ]}
                ]},
                {'直接指针访问':[
                    'reference中存储的是对象地址',
                    '对象头存储元数据的地址信息',
                    {'优势':[
                        '速度快',
                        '访问实例对象节省了一次指针定位的时间'
                    ]}
                ]}
            ]}
        ]}
    ]}],
'3.内存回收':[
    {'回收':[
        {'方法或者线程结束，自然回收':[
            '程序计数器',
            '虚拟机栈',
            '本地方法栈'
        ]},
        {'方法区回收':[
            '废弃的常量:没有对象引用时回收',
            {'不再使用的类型':[
                '类所有的实例都已经被回收',
                '加载该类的类加载器已经被回收',
                '类对应的Class对象没有被引用，无法通过反射访问'
            ]},
            '满足条件的类型，只是允许回收，是否能回收看配置'
        ]},
        {'对象回收':[
            {'引用计数法':[
                '对象被引用一次，计数器值+1',
                '引用失效，计数器值-1',
                '计数器为0的对象不再被使用',
                '问题：相互引用'
            ]},
            {'可达性分析法':[
                'GC Roots到对象不可达，对象不再被使用',
                {'GC Roots的对象':[
                    '虚拟机栈中引用的对象',
                    '方法区中类静态属性引用的对象',
                    '方法区中常量引用的对象，如字符串常量池（String Table）里的引用',
                    '本地方法栈中JNI（即Native方法）引用的对象',
                    {'虚拟机内部的引用':[
                        '基本数据类型对应的Class对象',
                        '常驻异常对象（如NullPointExcepiton）',
                        '系统类加载器'
                    ]},
                    '同步锁（synchronized关键字）持有的对象',
                    '反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存'
                ]}
            ]},
            {'四种引用':[
                {'强引用（StronglyReference）':[
                    '垃圾收集器永远不会回收掉被引用的对象'
                ]},
                {'软引用（Soft Reference）':[
                    '还有用，但非必须的对象',
                    '对象列进回收范围之中进行第二次回收',
                    'SoftReference类来实现'
                ]},
                {'弱引用（Weak Reference）':[
                    '非必须对象',
                    '弱引用关联的对象只生存到下一次垃圾收集发生为止',
                    'WeakReference类来实现'
                ]},
                {'虚引用（Phantom Reference）':[
                    '对象是否有虚引用，不对其生存时间构成影响，不能通过虚引用取得对象实例',
                    '存在目的：对象被收集器回收时收到一个系统通知',
                    'PhantomReference类来实现'
                ]}
            ]},
            {'宣告一个对象死亡':[
                '1.标记GC Roots不可达对象',
                '2.筛选对象是否可执行finalize()方法，将对象放置在F-Queue的队列中',
                '3.由低调度优先级的Finalizer线程去执行它们的finalize()方法',
                '4.收集器将对F-Queue中的对象进行第二次小规模的标记',
                '注：finalize()是对象逃脱死亡命运的最后一次机会'
            ]}
        ]}
    ]},
    {'垃圾收集算法':[
        {'名词定义':[
            '部分收集（Partial GC）：不是完整收集整个Java堆的垃圾收集',
            '新生代收集（Minor GC/Young GC）：只是新生代的垃圾收集',
            '老年代收集（Major GC/Old GC）：只是老年代的垃圾收集(CMS收集器)',
            '混合收集（Mixed GC）：整个新生代以及部分老年代的垃圾收集(G1收集器)',
            '整堆收集（Full GC）：整个Java堆和方法区的垃圾收集'
        ]},
        {'标记-清除算法':[
            '标记出需要回收的对象，完成后，统一回收掉被标记的对象',
            {'缺点':[
                '执行效率不稳定',
                '内存碎片化,用“分区空闲分配链表”解决内存分配问题，程序吞吐量下降'
            ]}
        ]},
        {'标记-复制算法':[
            '适用于新生代，每次GC存活对象少',
            '一块Eden，两块较小的Survivor，比例8：1',
            {'过程':[
                '垃圾收集',
                '将Eden和Survivor中存活的对象复制到另外的Survivor上',
                '清理掉Eden和用过的那块Survivor空间'
            ]},
            'Survivor空间不足时，依赖其他内存区域（大多是老年代）进行分配担保'
        ]},
        {'标记-整理算法':[
            '将存活对象向内存一端移动，然后清理掉边界以外的内存',
            {'缺点':[
                '停顿时间长，移动存活对象会更新所有引用这些对象的地方'
            ]}
        ]}
    ]},
    {'经典垃圾收集器':[
        {'专业名词':[
            {'根节点枚举':[
                'HotSpot使用一组称为OopMap的数据结构',
                '类加载完成时:把对象内什么偏移量上是什么类型的数据计算出来',
                '即时编译过程中:在特定的位置记录下栈里和寄存器里哪些位置是引用'
            ]},
            {'安全点':[
                '以“是否具有让程序长时间执行的特征”为原则进行选定',
                '方法调用、循环跳转、异常跳转这些位置都可能会设置有安全点',
                '可数循环:使用int类型或范围更小的数据类型作为索引值的循环',
                '不可数循环：使用long或者范围更大的数据类型作为索引值的循环',
                '虚拟机为了避免安全点过多，对循环做了优化，不可数循环才会被放置安全点',
                {'两种方案':[
                    {'抢先式中断':[
                        '所有用户线程都中断',
                        '如有用户线程中断不在安全点上，恢复线程，跑到安全点上再中断'
                    ]},
                    {'主动式中断':{
                        '设一个标志位，线程执行过程不断轮询，标志为真时自己在最近的安全点上中断挂起',
                        '轮询标志的地方和安全点是重合的'
                    }}
                ]},
            ]},
            {'安全区域':[
                '确保在某一段代码片段之中，引用关系不会发生变化'
            ]},
            {'记忆集与卡表':[
                {'记忆集':[
                    '一种用于记录从非收集区域指向收集区域指针集合的抽象数据结构',
                    '缩减GC Roots扫描范围'
                ]},
                {'卡精度':[
                    '每个记录精确到一块内存区域，该区域内有对象含有跨代指针',
                    '目前最常用的一种记忆集实现形式'
                ]},
                '卡页中有一个对象的字段存在着跨代指针，对应卡表的数组元素值标识为1，称元素变脏,没有标识为0',
                '垃圾收集发生时，筛选出卡表中变脏的元素，加入GC Roots中一并扫描',
                {'写屏障':[
                    '维护卡表状态'
                ]}
            ]},
            {'并行':[
                '一个处理器核处理一个任务',
                '同一时间多条垃圾收集器线程协同工作，默认此时用户线程处于等待状态'
            ]},
            {'并发':[
                '一个处理器核处理多个任务',
                '同一时间垃圾收集器线程与用户线程都在运行'
            ]}
        ]},
        {'新生代收集器':[
            {'Serial收集器':[
                '单线程',
                '简单，高效',
                '额外内存消耗最小,适合微服务',
                '标记复制算法'
            ]},
            {'ParNew收集器':[
                'Serial收集器的多线程并行版本',
                '除了Serial收集器，只有它能与CMS收集器配合工作',
                'ParNew收集器是激活CMS（使用-XX：+UseConcMarkSweepGC选项）的默认新生代收集器',
                '可以使用-XX：+/-UseParNewGC选项来强制指定或者禁用它'
            ]},
            {'Parallel Scavenge收集器':[
                '标记-复制算法',
                '目标是达到一个可控制的吞吐量',
                '最大垃圾收集停顿时间:-XX：MaxGCPauseMillis',
                '吞吐量:-XX：GCTimeRatio',
                '垃圾收集的自适应的调节策略:-XX：+UseAdaptiveSizePolicy'
            ]}
        ]},
        {'老生代收集器':[
            {'Serial Old收集器':[
                '单线程',
                '标记-整理',
                {'两种用途':[
                    'JDK 5及之前与Parallel Scavenge收集器搭配使用',
                    'CMS收集器失败时的后备预案，并发收集发生Concurrent Mode Failure时使用'
                ]}
            ]},
            {'Parallel Old收集器':[
                '支持多线程并发收集',
                '标记-整理算法'
            ]},
            {'CMS收集器':[
                '目标：获取最短回收停顿时间',
                '标记-清除算法',
                '并发收集、低停顿',
                {'四个步骤':[
                    '初始标记（CMS initial mark）：标记GC Roots能直接关联到的对象',
                    '并发标记（CMS concurrent mark）：从GC Roots的直接关联对象开始遍历整个对象图',
                    '重新标记（CMS remark）：修正并发标记期间，因用户程序运作导致标记产生变动的对象标记记录',
                    '并发清除（CMS concurrent sweep）：清理删除掉标记阶段判断已经死亡的对象'
                ]},
                '初始标记、重新标记两个步骤需要“Stop The World”',
                {'缺点':[
                    '占用部分线程导致应用程序变慢，降低总吞吐量',
                    '无法处理“浮动垃圾”：并发标记和并发清理阶段产生的',
                    '空间碎片过多'
                ]}
            ]},
            {'Garbage First收集器':[
                {'基于Region的内存布局形式':[
                    '将Java堆划分为多个大小相等的独立区域',
                    '每个Region可以扮演新生代的Eden空间、Survivor空间，老年代空间',
                    'Region大小:-XX：G1HeapRegionSize，取值范围为1MB～32MB，为2的N次幂',
                    '收集停顿时间:-XX：MaxGCPauseMillis，默认值是200毫秒'
                ]},
                {'大对象回收':[
                    'Region有特殊的Humongous区域，用来存储大对象（超过了Region容量一半的对象）',
                    '超过整个Region容量的大对象，放在N个连续的Humongous Region之中,作为老年代的一部分'
                ]},
                'JDK 10,统一了垃圾收集器接口，将内存回收的“行为”与“实现”进行分离',
                '跟踪Region里面的垃圾堆积的大小，在后台维护一个优先级列表,优先处理回收价值大的Region',
                {'四个步骤':[
                    {'初始标记':[
                        '标记一下GC Roots能直接关联到的对象',
                        '修改TAMS指针的值',
                        '需要停顿线程，但耗时很短'
                    ]},
                    {'并发标记':[
                        '从GC Root开始对堆中对象进行可达性分析',
                        '递归扫描整个堆里的对象图，找出回收对象，耗时长',
                        '可与用户程序并发执行',
                        '要重新处理SATB记录下的在并发时有引用变动的对象'
                    ]},
                    {'最终标记':[
                        '需停顿线程',
                        '处理并发阶段结束后遗留下来的少量SATB记录'
                    ]},
                    {'筛选回收':[
                        '更新Region统计数据，对各个Region的回收价值和成本进行排序',
                        '自由选择任意多个Region构成回收集',
                        '把回收Region的存活对象复制到空的Region中',
                        '清理掉整个旧Region空间',
                        '存活对象的移动，须暂停用户线程'
                    ]},
                    '理念：应付应用的内存分配速率，不追求一次把整个Java堆全部清理干净'
                ]},
                {'与CMS对比':[
                    'G1优点:指定最大停顿时间、分Region的内存布局、按收益动态确定回收集,标记-复制算法',
                    'G1缺点:内存占用,程序运行时的额外执行负载都要比CMS要高'
                ]}
            ]}
        ]},
        {'低延迟垃圾收集器':[
            {'垃圾收集器的三项指标':[
                '内存占用（Footprint）',
                '吞吐量（Throughput）',
                '延迟（Latency）:最被重视'
            ]},
            'ZGC收集器'
        ]},
        {'垃圾收集器工作':[
            '对象优先在Eden分配',
            {'大对象直接进入老年代':[
                '-XX：PretenureSizeThreshold:大于该值的对象直接在老年代分配',
                '上述参数只对Serial和ParNew两款新生代收集器有效',
                '避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作'
            ]},
            {'长期存活的对象将进入老年代':[
                'XX：MaxTenuringThreshold:对象晋升老年代的年龄阈值,默15'
            ]},
            {'动态对象年龄判定':[
                'Survivor中相同年龄所有对象大小>Survivor的一半',
                '年龄>=该年龄的对象直接进入老年代'
            ]},
            {'空间分配担保':[
                '老年代的连续空间>新生代对象总大小or历次晋升的平均大小，进行Minor GC，否则进行Full GC'
            ]}
        ]}
    ]}],
'4.JVM性能监控与调优':[
    {'基础工具':[
        {'JHSDB':[
            '一款基于服务性代理实现的进程外调试工具'
        ]},
        {'JConsole':[
            '一款基于JMX的可视化监视、管理工具',
            '主要功能是通过JMX的MBean（Managed Bean）对系统进行信息收集和参数动态调整'
        ]},
        {'VisualVM':[
            '功能最强大的运行监视和故障处理程序之一',
            'jvisualvm.exe:图形化工具，提供内存，CPU,堆转储分析，内存泄漏检测'
        ]},
        {'Java Mission Control':[
            '可持续在线的监控工具'
        ]}
    ]},
    {'HotSpot虚拟机插件HSDIS':[
        '一个被官方推荐的HotSpot虚拟机即时编译代码的反汇编插件',
        '-XX：+PrintAssembly指令：把即时编译器动态生成的本地代码->汇编代码',
        'JITWatch：HSDIS经常搭配使用的可视化的编译日志分析工具'
    ]},
    {'调优案例分析':[
        {'大内存硬件上的程序部署策略':[
            {'1.单虚拟机管理大内存':[
                'a.用G1收集器,Shenandoah、ZGC等，可控制延迟',
                {'b.用Parallel Scavenge/Old等':[
                    '传统收集器需把Full GC频率控制得足够低',
                    '低到不会在用户使用过程中发生，如十几个小时，一天不出现一次Full GC',
                    '可深夜以定时任务方式触发Full GC或自动重启应用服务器',
                    '控制Full GC频率关键：老年代的相对稳定',
                    '大多数对象能否符合“朝生夕灭”的原则',
                    '发生堆内存溢出，几乎无法产生堆转储快照,即使有分析也很困难'
                ]}
            ]},
            {'2.多虚拟机，逻辑集群':[
                '一台物理机器启动多个应用服务器进程，每个服务器进程配不同端口',
                '然后前端搭建一个负载均衡器，反向代理方式分配访问请求',
                {'无Session复制的亲合式集群':[
                    '均衡器按一定的规则算法将一个用户请求永远分配到一个固定集群节点',
                    '程序开发阶段就几乎不必为集群环境做任何特别的考虑'
                ]}
            ]}
        ]},
        '集群间同步导致的内存溢出',
        {'堆外内存导致的溢出错误':[
            {'直接内存':[
                '-XX：MaxDirectMemorySize调整大小',
                '内存不足时抛出OutOf-MemoryError',
                '或OutOfMemoryError：Direct buffer memory'
            ]},
            {'线程堆栈':[
                '通过-Xss调整大小',
                '内存不足时抛出StackOverflowError（线程请求的栈深度>虚拟机允许深度）',
                'OutOfMemoryError（栈扩展时无法申请到足够的内存）'
            ]},
            {'Socket缓存区':[
                '每个Socket连接都Receive和Send两个缓存区，分别占大约37KB和25KB内存',
                '连接多的话,如无法分配，抛出IOException：Too many open files异常'
            ]},
            {'JNI代码':[
                '代码中使用JNI调用本地库',
                '本地库用的是本地方法栈和本地内存的，不是堆内存'
            ]}
        ]},
        '外部命令导致系统缓慢',
        {'服务器虚拟机进程崩溃':[
            'http请求响应超时',
            '->等待线程和Socket连接越来越多',
            '->超过虚拟机承受能力',
            '->虚拟机进程崩溃',
            '解决：异步调用可改为消息模式'
        ]},
        '不恰当数据结构导致内存占用过大:以HashMap<Long，Long>Entry为例',
        {'Windows虚拟内存导致的长时间停顿':[
            '程序在最小化时它的工作内存被自动交换到磁盘的页面文件之中',
            '垃圾收集时因为恢复页面文件的操作导致不正常的垃圾收集停顿',
            '加入参数“-Dsun.awt.keepWorkingSetOnMinimize=true”'
        ]},
        {'安全点导致长时间停顿':[
            '可数循环没有放置安全点->循环很慢导致停顿',
            '循环索引的数据类型int改为long，可数循环变为不可数循环'
        ]}
    ]}],
'5.类文件与字节码':[
    {'类文件':[
        '.java->.class(字节码)->虚拟机',
        {'特点':[
            '一组以8个字节为基础单位的二进制流',
            '两种数据类型:"无符号数"和"表"',
            {'无符号数':[
                '基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节。。。',
                '可用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值'
            ]},
            {'表':[
                '多个无符号数或者其他表作为数据项构成的复合数据类型,命名习惯以"_info"结尾',
                '描述有层次关系的复合结构数据，Class文件本质上也是一张表'
            ]},
            {'集合':[
                '当需描述同一类型但数量不定的多个数据时，形式：一个前置的容量计数器+若干连续的数据项'
            ]}
        ]},
        {'结构':[
            {'魔数与Class文件版本':[
                '每个Class文件头4个字节称为魔数，作用是确定这个文件是否为一个能被虚拟机接受的Class文件',
                '魔数内容：0xCAFEBABE（咖啡宝贝？）',
                '第5，6字节是次版本号（MinorVersion），第7，8字节是主版本号（Major Version）'
            ]},
            {'常量池':[
                '紧接主、次版本号',
                'Class文件里的资源库，是Class文件结构中与其他项目关联最多的数据',
                {'分类':[
                    {'字面量':[
                        '近Java常量概念，如文本字符串、final型常量值等',
                        '常量池中每一项常量都是一个表',
                        '常量表中有17种不同类型的常量'
                    ]},
                    '符号引用'
                ]},
            ]},
            {'访问标志':[
                '常量池后，紧接着的2个字节',
                '用于识别类或者接口层次的访问信息',
                {'包括':[
                    '这个Class是类还是接口',
                    '是否定义为public类型',
                    '是否定义为abstract类型',
                    '如果是类的话，是否被声明为final'
                ]}
            ]},
            {'类索引、父类索引与接口索引集合':[
                '按顺序排列在访问标志后',
                '类索引和父类索引:用两个u2类型的索引值表示',
                '指向一个类型为CONSTANT_Class_info的类描述符常量',
                '常量中的索引值可以找到定义在CONSTANT_Utf8_info类型常量中的全限定名字符串'
            ]},
            {'字段表集合':[
                {'字段表（field_info）':[
                    '描述接口或者类中声明的变量',
                    '包括类级变量以及实例级变量',
                    '不包括方法内部声明的局部变量'
                ]},
                '字段修饰符(access_flags):一个u2的数据类型',
                '字段的简单名称(name_index)和方法的描述符(descriptor_index):两项索引值,是对常量池项的引用',
                {'方法和字段的描述符':[
                    '描述字段数据类型、方法参数列表（包括数量、类型以及顺序）和返回值',
                    '描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照顺序放在小括号“()”内',
                    '基本数据类型（byte、char、double、float、int、long、short、boolean）及无返回值void类型用一个大写字符表示',
                    '对象类型用字符L加对象的全限定名来表示'
                ]}
            ]},
            {'方法表集合':[
                '标志（access_flags）',
                '名称索引（name_index）',
                '描述符索引（descriptor_index）',
                '属性表集合（attributes）'
            ]},
            {'属性表集合':[
                '属性表（attribute_info）:Class文件、字段表、方法表都可携带自己的属性表集合',
                {'Code属性':[
                    'attribute_name_index:一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，代表了该属性的属性名称',
                    'attribute_length:属性值的长度，属性名称索+与属性长度共6个字节，属性值长度=整个属性表长度-6个字节',
                    'max_stack:操作数栈最大深度,在方法执行的任意时刻，操作数栈都不会超过这个深度',
                    'max_locals:局部变量表所需的存储空间,单位变量槽（Slot），变量槽是虚拟机为局部变量分配内存所使用的最小单位',
                    'code_length和code：存储Java源程序编译后生成的字节码指令',
                    'code_length：字节码长度',
                    'code：存储字节码指令的一系列字节流'
                ]},
                {'Exceptions属性':[
                    '列举出方法中可能抛出的受查异常，即方法描述时在throws关键字后面列举的异常'
                ]}
            ]}
        ]}]},
    {'字节码指令':[
        {'重要概念':[
            'JVM采用面向操作数栈的架构(区别面向寄存器）',
            '指令大多：只一个操作码，指令参数放在操作数栈中',
            '操作码长度为一个字节（即0～255）,指令集的操作码总数<=256条',
            '处理超过一个字节数据时，运行时从字节中重建出具体数据结构'
        ]},
        {'字节码与数据类型':[
            'iload指令:从局部变量表中加载int型的数据到操作数栈中,fload指令加载的是float类型数据',
            '两条指令的操作在JVM内部可能是同一段代码，但在Class文件中它们必须拥有各自独立的操作码',
            '大部分与数据类型相关的字节码指令，其操作码助记符都有特殊字符表明为哪种数据类型服务'
        ]},
        {'加载和存储指令':[
            '将数据在栈帧中的局部变量表和操作数栈之间来回传输',
            '将一个局部变量加载到操作栈：iload',
            '将一个数值从操作数栈存储到局部变量表：istore',
            '将一个常量加载到操作数栈：bipush',
            '扩充局部变量表的访问索引的指令：wide'
        ]},
        {'运算指令':[
            '对两个操作数栈上的值进行特定运算，并把结果重存入到操作栈顶',
            '加法指令：iadd,·减法指令：isub,乘法指令：imul,除法指令：idiv',
            '求余指令：irem,取反指令：ineg,位移指令：ishl',
            '位移指令：ishl,按位或指令：ior,按位与指令：iand',
            '比较指令：dcmpg'
        ]},
        {'类型转换指令':[
            '直接支持宽化类型转换,窄化类型转换须显式地使用转换指令',
            'int类型到long、float或者double类型',
            'long类型到float、double类型',
            'float类型到double类型'
        ]},
        {'对象创建与访问指令':[
            '创建类实例指令：new',
            '创建数组指令：newarray、anewarray、multianewarray',
            '访问类字段（static字段）和实例字段指令：getfield、putfield、getstatic、putstatic',
            '把数组元素加载到操作数栈的指令：baload、caload、saload、iaload、laload、faload、daload、aaload',
            '将操作数栈的值储存到数组元素中的指令：bastore、castore、sastore、iastore、fastore、dastore、aastore',
            '取数组长度指令：arraylength',
            '检查类实例类型指令：instanceof、checkcast'
        ]},
        {'操作数栈管理指令':[
            '将操作数栈的栈顶一个或两个元素出栈：pop、pop2',
            '复制栈顶一或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1、dup2_x1、dup_x2、dup2_x2',
            '将栈最顶端的两个数值互换：swap'
        ]},
        {'控制转移指令':[
            '条件分支：ifeq、iflt、ifle、ifne',
            '复合条件分支：tableswitch、lookupswitch',
            '无条件分支：goto、goto_w、jsr、jsr_w、ret'
        ]},
        {'方法调用和返回指令':[
            'invokevirtual指令：调用对象的实例方法，根据对象的实际类型进行分派（虚方法分派）',
            'invokeinterface指令：调用接口方法，会在运行时搜索一个实现了接口方法的对象，找出适合的方法进行调用',
            'invokespecial指令：调用需要特殊处理的实例方法，包括实例初始化方法、私有方法和父类方法',
            'invokestatic指令：调用类静态方法（static方法）',
            'invokedynamic指令：在运行时动态解析出调用点限定符所引用的方法'
        ]},
        {'异常处理指令':[
            'athrow'
        ]},
        {'同步指令':[
            'monitorenter+monitorexit'
        ]}
    ]}],
'6.类加载':[
    {'类的生命周期':[
        '加载（Loading',
        {'连接':[
            '验证（Verification）',
            '准备（Preparation）',
            '解析（Resolution）'
        ]},
        '初始化（Initialization）',
        '使用（Using）',
        '卸载（Unloading）'  
    ]},
    {'过程':[
        {'加载：三阶段':[
            '1.通过类的全限定名来获取定义此类的二进制字节流',
            '2.将字节流所代表的静态存储结构转化为方法区的运行时数据结构',
            '3.生成代表此类的java.lang.Class对象，作为方法区类各种数据的访问入口'
        ]},
        {'验证':[
            '目的：确保Class文件的字节流包含信息符合要求',
            {'四阶段':[
                {'文件格式验证':[
                    '目的：保证输入的字节流能正确地解析并存储于方法区',
                    '基于二进制字节流进行的，通过，字节流才被允许进入JVM内存的方法区中进行存储',
                    '后面三个验证阶段全是基于方法区的存储结构，不会再直接读取、操作字节流'
                ]},
                {'元数据验证':[
                    '对字节码描述的信息进行语义分析'
                ]},
                {'字节码验证':[
                    '目的：通过数据流和控制流分析，确保程序语义合法、符合逻辑',
                    '对类的方法体（Class文件中的Code属性）进行校验分析'
                ]},
                {'符号引用验证':[
                    '目的：确保解析行为能正常执行',
                    '解析阶段，会将符号引用转化为直接引用'
                ]}
            ]}
        ]},
        {'准备':[
            '为类中定义的变量分配内存并设置初始值',
            {'类中定义的变量':[
                '仅包括类变量，不包括实例变量',
                '实例变量将会在对象实例化时随着对象一起分配在Java堆中'
            ]},
            {'内存':[
                'JDK 8后变量的内存也是指Java堆，方法区只是一种逻辑概念'
            ]},
            {'初始值':[
                '通常情况下是数据类型的零值',
                '特殊：类字段的字段属性表中存在ConstantValue属性，变量值就会被初始化为属性所指定的初始值'
            ]}
        ]},
        {'解析':[
            {'定义':[
                '将常量池内的符号引用替换为直接引用的过程',
                {'符号引用':[
                    '以一组符号来描述所引用目标'
                ]},
                {'直接引用':[
                    '直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄',
                    '和内存布局相关,如果有了直接引用，那引用的目标必已在内存中存在'
                ]}
            ]},
            {'针对的符号引用类型':[
                    '类',
                    '接口',
                    '字段',
                    '类方法',
                    '接口方法',
                    '方法类型',
                    '方法句柄',
                    '调用点限定符'
            ]},
            {'对应于常量池的8种常量类型':[
                'CONSTANT_Class_info',
                'CON-STANT_Fieldref_info',
                'CONSTANT_Methodref_info',
                'CONSTANT_InterfaceMethodref_info',
                'CONSTANT_MethodType_info',
                'CONSTANT_MethodHandle_info',
                'CONSTANT_Dyna-mic_info',
                'CONSTANT_InvokeDynamic_info'
            ]}
        ]},
        {'初始化':[
            '执行类构造器<clinit>()方法的过程',
            {'<clinit>()内容':[
                '所有类变量的赋值动作',
                '静态语句块（static{}块）'
            ]},
            {'条件':[
                '1.遇到new、getstatic、putstatic或invokestatic这四条字节码指令时',
                '2.使用java.lang.reflect包的方法对类型进行反射调用时',
                {'3.初始化类的时，其父类还未初始化':[
                    '类在初始化时，要求其父类全部都已经初始化过了',
                    '接口在初始化时，不要求其父接口初始化,在使用到父接口的时候才会初始化'
                ]},
                '4.虚拟机启动时，用户指定的主类（包含main()方法的那个类）',
                {'5.一个java.lang.invoke.MethodHandle实例最后的解析结果为下面四种类型的方法句柄时':[
                    'REF_getStatic',
                    'REF_putStatic',
                    'REF_invokeStatic',
                    'REF_newInvokeSpecial'
                ]},
                '6.当一个接口中定义了JDK8新加的默认方法时，如接口的实现类发生了初始化，接口要在其之前被初始化'
            ]}
        ]}
    ]},
    {'类加载器':[
        {'类加载器':[
            {'定义':[
                '通过一个类的全限定名来获取描述该类的二进制字节流',
                '动作放在Java虚拟机外部实现，方便应用程序决定如何去获取所需的类',
                '任意一个类，由加载它的类加载器+类本身共同确立其在Java虚拟机中的唯一性',
                '每一个类加载器，都拥有一个独立的类名称空间'
            ]},
            {'分类':[
                '启动类加载器(BootstrapClassLoader):C++语言实现，虚拟机自身的一部分',
                '其他类加载器:Java语言实现,继承自抽象类java.lang.ClassLoader,独立存在于虚拟机外部'
            ]}
        ]},
        {'双亲委派模型':[
            'Java一直保持着三层类加载器、双亲委派的类加载架构',
            {'三个系统提供的类加载器':[
                '启动类加载器（Bootstrap Class Loader）',
                '扩展类加载器（Extension Class Loader)',
                '应用程序类加载器（Application Class Loader)'
            ]},
            {'要求':[
                '除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器',
                '类加载器之间的父子关系不以继承，而是使用组合关系来复用父加载器的代码'
            ]},
            {'工作过程':[
                '如果一个类加载器收到了类加载的请求，不会尝试加载这个类，而是把请求委派给父类加载器',
                '每一个层次的类加载器都是如此,所有的加载请求最终都传送到最顶层的启动类加载器中',
                '当父加载器反馈自己无法完成这个加载请求时，子加载器会尝试自己去完成加载'
            ]},
            {'优点':[
                'Java中的类随着它的类加载器一起具备了一种带有优先级的层次关系'
            ]}
        ]}
    ]}],
'7.字节码执行引擎':[
    {'栈帧':[
        {'背景':[
            'Java虚拟机以方法作为最基本的执行单元',
        ]},
        {'目的':[
            '支持虚拟机进行方法调用和方法执行'
        ]},
        {'内容':[
            {'局部变量表':[
                '一组变量值的存储空间，单位：变量槽',
                '存放方法参数和方法内部定义的局部变量',
                {'方法被调用时':[
                    '虚拟机会使用局部变量表来完成实参到形参的传递',
                    '即参数值到参数变量列表的传递过程'
                ]},
                {'实例方法（未被static修饰）被调用':[
                    '第0位变量槽默认传递方法所属对象实例的引用',
                    '方法中可通过this来访问这个隐含的参数',
                    '其余参数按照参数表顺序排列，占用从1开始的变量槽',
                    '参数分配完毕，根据方法体内部定义的变量顺序和作用域分配其余变量槽'
                ]},
                {'注意':[
                    '局部变量要赋初始值',
                    '类变量不需要，因为它在<准备阶段>会赋默认值'
                ]} 
            ]},
            {'操作数栈':[
                '最大深度编译时确认，存在Code属性的max_stacks数据项'
            ]},
            {'栈帧间的数据共享':[
                '下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠',
                '节约空间，方法调用时直接共用部分数据，无须进行额外的参数复制',
            ]},
            {'动态连接':[
                '运行期间将符号引用->直接引用'
            ]},
            {'方法返回地址':[
                '正常调用完成',
                '方法执行过程遇异常，且异常没有在方法体内处理'
            ]}
        ]}
    ]},
    {'方法调用':[
        '任务：确定被调用方法版本，不涉及方法内部具体运行过程',
        {'五条字节码指令':[
            'invokestatic：调用静态方法',
            'invokespecial：调用实例构造器<init>()方法、私有方法和父类中的方法',
            'invokevirtual：调用所有的虚方法',
            'invokeinterface：调用接口方法，在运行时确定一个实现该接口的对象',
            'invokedynamic：运行时动态解析出调用点限定符所引用的方法，然后再执行该方法'
        ]},
        {'解析':[
            {'定义':[
                '静态过程',
                '编译期间确定',
                '把符号引用转变为直接引用,确定唯一的方法调用版本',
                '如能被invokestatic和invokespecial指令调用的方法'
            ]},
            {'分类':[
                '静态方法:与类型直接关联，不能通过重写出现别的版本，适合类加载阶段进行解析',
                '私有方法:外部不可被访问，不能通过继承出现别的版本，适合类加载阶段进行解析',
                '实例构造器',
                '父类方法',
                '被final修饰的方法（invokevirtual指令调用)：无法被覆盖，没有其他版本的可能'
            ]},
        ]},
        {'分派':[
            {'静态分派':[
                {'定义':[
                    '依赖静态类型决定方法执行版本',
                    '发生在编译阶段，不由虚拟机来执行的',
                    '典型表现:方法重载'
                ]},
                {'重载':[
                    '通过参数的静态类型而不是实际类型作为判定依据的',
                    '静态类型是在编译期可知',
                    '实际类型在运行期才可确认'
                ]},
                {'重载时目标方法选择优先级':[
                    '1.char>int>long>float>double的顺序转型进行匹配',
                    '2.一次自动装箱,封装类型java.lang.Character',
                    '3.java.lang.Serializable,是java.lang.Character类实现的一个接口',
                    '自动装箱之后还是找不到装箱类，会找装箱类所实现的接口类型',
                    '3.Object,如果有多个父类，那将在继承关系中从下往上开始搜索',
                    '4.变长参数的重载优先级是最低的'
                ]}
            ]},
            {'动态分派':[
                {'定义':[
                    '运行期根据实际类型确定方法执行版本的分派动作',
                    '典型表现:重写（Override）'
                ]},
                {'invokevirtual指令运行时解析过程':[
                    '1.找到操作数栈顶的第一个元素所指向的对象实际类型，记作C',
                    '2.在类型C中找到与常量中的描述符和简单名称都相符的方法',
                    '找得到，进行访问权限校验',
                    '通过则返回方法的直接引用，查找过程结束',
                    '不通过则返回java.lang.IllegalAccessError异常',
                    '3.找不到，按照继承关系从下往上对C的各个父类进行搜索和验证',
                    '4.如始终没有找到合适的方法，抛出java.lang.AbstractMethodError'
                ]},
                {'方法重写本质':[
                    'invokevirtual指令执行的第一步：在运行期确定接收者的实际类型',
                    '根据方法接收者的实际类型来选择方法版本',
                    '把常量池中方法的符号引用解析到直接引用上'
                ]}
            ]},
            {'单分派与多分派':[
                '方法的宗量：方法的接收者与参数',
                '单分派：根据一个宗量对目标方法进行选择',
                '多分派: 根据多个宗量对目标方法进行选择',
                {'静态分派,选择目标方法的依据':[
                    '静态类型',
                    '方法参数',
                    'Java语言的静态分派属于多分派类型,根据两个宗量进行选择'
                ]},
                 {'动态分派,选择目标方法的依据':[
                    '方法接受者的实际类型'
                ]}
            ]},
            {'动态分派实现':[
                '方法版本选择过程需在【接收者类型的方法元数据】中搜索目标方法',
                '优化手段:为类型在方法区中建【虚方法表】,使用虚方法表索引来代替元数据查找',
                '虚方法表在类加载连接阶段进行初始化，类的变量初始值后，把类的虚方法表一同初始化'
            ]}
        ]}
    ]},
    {'动态类型语言':[
        {'关键特征':[
            '类型检查的主体过程是在【运行期】而不是编译期进行的',
            '变量无类型而变量值才有类型'
        ]},
        {'Java与动态类型':[
            '之前：单纯依靠符号引用来确定调用的目标方法',
            'java.lang.invoke包:提供一种新的动态确定目标方法的机制(方法句柄)'
        ]},
        {'invokedynamic指令':[
            {'动态调用点':[
                '每一处含有invokedynamic指令的位置'
            ]},
            {'第一个参数':[
                {'CONSTANT_InvokeDynamic_info常量':[
                    {'引导方法':[
                        '存放在新增的BootstrapMethods属性中',
                        '有固定的参数，返回值是java.lang.invoke.CallSite对象,代表真正要执行的目标方法调用',
                        '根据常量中提供信息，虚拟机可以找到并且执行引导方法，获得一个CallSite对象',
                        '通过CallSite对象，最终调用到要执行的目标方法上'
                    ]},
                    '方法类型',
                    '名称'
                ]},
                '不再是代表方法符号引用的CONSTANT_Methodref_info常量'
            ]},
        ]}
    ]},
    {'基于栈的字节码解释执行引擎':[
        {'虚拟机执行方法里的字节码指令':[
            '解释执行（通过解释器执行）',
            '编译执行（通过即时编译器产生本地代码执行）'
        ]},
        {'编译过程':[
            '1.程序源码->词法分析->语法分析->抽象语法树',
            '2.抽象语法树->指令流（可选）->解释器->解释执行',
            '3.抽象语法树->优化器（可选）->中间代码（可选）->生成器->目标代码'
        ]},
        {'Javac编译器':[
            'Java程序的编译：程序代码->词法分析->语法分析->抽象语法树->遍历语法树->线性的字节码指令流',
            '上述都在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译是半独立'
        ]},
        {'基于栈和基于寄存器的指令集':[
            '栈结构指令集：字节码指令流里指令大部分是零地址指令，依赖操作数栈进行工作',
            '整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径',
            '寄存器的指令集:依赖寄存器进行工作'
        ]}
    ]}],
'8.类加载及执行子系统的案例':[
    {'Tomcat：正统的类加载器架构':[
        {'Tomcat目录结构':[
            '/common:类库可被Tomcat和Web应用程序共同使用;使用Common类加载器加载',
            '/server:类库可被Tomcat使用，对Web应用程序不可见;使用Catalina类加载器加载',
            '/shared:类库可被Web应用程序使用，对Tomcat不可见;使用Shared类加载器加载',
            '/WebApp/WEB-INF:类库仅可被该Web应用程序使用，对Tomcat和其他Web应用程序不可见;使用WebApp类加载器加载'
        ]},
        '为支持这套目录结构，并对目录里面的类库进行加载和隔离，Tomcat按照经典的双亲委派模型自定义了多个类加载器',
        {'JasperLoader类加载器':[
            '加载范围仅仅是这个JSP文件所编译出来的Class文件',
            '服务器检测到JSP文件被修改，会建立一个新的JSP类加载器替换掉目前的，实现JSP文件HotSwap功能'
        ]},
        'Tomcat 6及之后的版本:/common、/server和/shared这3个目录默认合并到一起变成1个/lib目录'
    ]},
    'OSGi：灵活的类加载器架构',
    '字节码生成技术与动态代理的实现',
    'Backport工具：Java的时光机器',
    {'实现远程执行功能':[
        {'思路':[
            {'如何编译提交到服务器的Java代码':[
                '客户端编译好，把字节码而不是Java代码传到服务端'
            ]},
            {'如何执行编译之后的Java代码':[
                '让类加载器加载这个类生成一个Class对象，然后反射调用方法'
            ]},
            {'如何收集Java代码的执行结果':[
                '直接在执行的类中把对System.out的符号引用替换为我们准备的PrintStream的符号引用'
            ]}
        ]},
        {'实现':[
            'HotSwapClassLoader:实现“同一个类的代码可以被多次加载”',
            'ClassModifier:修改符合Class文件格式的byte[]数组中的常量池部分',
            '将常量池中指定内容的CONSTANT_Utf8_info常量替换为新的字符串',
            'HackSystem:代替java.lang.System',
            'JavaclassExecuter:提供给外部调用的入口，调用前面几个支持类组装逻辑，完成类加载工作'
        ]}
    ]}],
'9.程序编译':[
    {'分类':[
        {'前端编译器':[
            '编译期的优化过程',
            '很多Java语法新特性，是靠编译器的“语法糖”来实现',
            '不依赖字节码或者Java虚拟机的底层改进'
        ]},
        {'后端编译器':[
            '即时编译器在运行期的优化过程'
        ]}
    ]},
    {'Javac编译器':[
        '由Java语言编写的程序',
        {'编译入口':[
            'com.sun.tools.javac.main.JavaCompiler类的compile()方法'
        ]},
        {'编译过程':[
            {'准备过程':[
                '初始化插入式注解处理器'
            ]},
            {'解析与填充符号表':[
                '词法、语法分析',
                '将源代码的字符流转变为标记集合，构造出抽象语法树',
                '填充符号表，产生符号地址和符号信息'
            ]},
            '注解处理',
            {'分析与字节码生成':[
                '标注检查:对语法的静态信息进行检查',
                '数据流及控制流分析:对程序动态运行过程进行检查',
                '解语法糖:将简化代码编写的语法糖还原为原有的形式',
                '字节码生成:将前面各个步骤所生成的信息转化成字节码'
            ]}
        ]},
        {'解析与填充符号表':[
            {'词法分析':[
                '字符流->标记集合',
                '单个字符:程序编写时的最小元素',
                '标记:编译时的最小元素',
                'com.sun.tools.javac.parser.Scanner类实现'
            ]},
            {'语法分析':[
                '标记序列->抽象语法树',
                'com.sun.tools.javac.parser.Parser类实现',
                {'抽象语法树':[
                    '用来描述程序代码语法结构',
                    '每一个节点都代表着程序代码中的一个语法结构',
                    '如包、类型、修饰符、运算符、接口、返回值、代码注释等'
                ]},
                '抽象语法树以com.sun.tools.javac.tree.JCTree类表示'
            ]},
            {'填充符号表':[
                {'符号表':[
                    '符号地址+符号信息'
                ]},
                {'作用':[
                    '语义分析阶段: 语义检查和产生中间代码',
                    '目标代码生成阶段: 根据符号表进行地址分配'
                ]},
                '   com.sun.tools.javac.comp.Enter类实现'
            ]}
        ]},
        {'注解处理器':[
            '类似插件，可CRUD抽象语法树中的任意元素',
            '解析与填充符号表->注解处理器,是一个循环过程，直到注解处理器不再对语法树进行修改',
            {'应用':[
                'Lombok:通过注解来实现自动产生getter/setter/equals()/hashCode()方法等'
            ]},
            'com.sun.tools.javac.processing.JavacProcessingEnvironment类的doProcessing()方法',
            '生成一个新的JavaCompiler对象，对编译的后续步骤进行处理'
        ]},
        {'语义分析与字节码生成':[
            {'作用':[
                '对结构上正确的源程序进行上下文相关检查'
            ]},
            {'标注检查':[
                '变量使用前是否已被声明',
                '变量与赋值之间的数据类型是否能够匹配',
                '实现类com.sun.tools.javac.comp.Attr',
                '实现类com.sun.tools.javac.comp.Check'
            ]},
            {'数据及控制流分析':[
                '程序局部变量在使用前是否有赋值',
                '方法的每条路径是否都有返回值',
                '是否所有的受查异常都被正确处理',
                '实现类com.sun.tools.javac.comp.Flow'
            ]},
            {'解语法糖':[
                {'语法糖定义':[
                    '某种语法，对语言的编译结果和功能并没有实际影响，但可以方便程序员使用'
                ]},
                {'应用':[
                    {'泛型':[
                        '本质：参数化类型（Parameterized Type）',
                        '能够用在类、接口和方法的创建中，分别构成泛型类、泛型接口和泛型方法',
                        {'擦除法实现':[
                            '对方法的Code属性中的字节码进行擦除',
                            '元数据中会保留泛型信息，反射手段可以取得参数化类型',
                            '缺点是比较慢，会频繁构造包装类和装箱、拆箱'
                        ]}
                    ]},
                    {'自动装箱、拆箱与遍历循环':[
                        '包装类的“==”运算遇到算术运算自动拆箱',
                        '包装类的equals()方法不处理数据转型'
                    ]},
                    '条件编译'
                ]},
                {'解语法糖定义':[
                    '编译阶段被还原回原始的基础语法结构'
                ]},
                '实现类com.sun.tools.javac.comp.TransTypes',
                '实现类com.sun.tools.javac.comp.Lower'
            ]},
            {'字节码生成':[
                'com.sun.tools.javac.jvm.Gen类完成',
                '把前面各步骤所生成的信息（语法树、符号表）转化成字节码指令写到磁盘',
                {'进行了少量代码添加和转换':[
                    '将实例构造器<init>()和类构造器<clinit>()方法添加到语法树中',
                    '如把字符串的加操作替换为StringBuffer或StringBuilder'
                ]}
            ]}
        ]}
    ]}],
'10.后端编译':[
    {'编译器目标':[
        '将程序代码翻译为本地机器码',
        '优化代码'
    ]},
    {'解释器':[
        'Java程序最初都是通过解释器进行解释执行的'
    ]},
    {'即时编译器':[
        {'编译器编译的目标：热点代码':[
            '被多次调用的方法',
            '被多次执行的循环体'
        ]},
        {'编译的目标对象':[
            '整个方法体,对于循环体,执行入口会稍有不同',
        ]},
        {'即时编译器':[
            '运行时，将代码编译成本地机器码,并尽可能优化代码,提高热点代码执行效率'
        ]},
        {'HotSpot虚拟机内置的个即时编译器':[
            '客户端编译器”（Client Compiler）',
            '服务端编译器”（Server Compiler）',
            'Graal编译器'
        ]},
        {'触发条件:热点探测':[
            '基于采样',
            {'基于计数器':[
                '方法调用计数器',
                '回边计数器,回边:在循环边界往回跳转',
                '方法调用计数器热度衰减'
            ]},
            '两计数器有明确阈值，阈值一旦溢出，会触发即时编译'
        ]},
        {'编译过程':[
            '1.字节码->HIR(优化：方法内联，常量传播等）',
            '2.HIR->LIR(优化：空值检查消除，范围检查消除等）',
            '3.LIR->本地代码(寄存器分配，窥孔优化，机器码生成）'
        ]},
        {'优点':[
            '性能分析制导优化',
            '激进预测性优化:不行就回退',
            '链接时优化'
        ]},
        {'缺点':[
            '占用程序运行时间和运算资源'
        ]},
    ]},
    {'提前编译器':[
        '传统的静态提前编译',
        '做即时编译的缓存'
    ]}],
'11.编译器优化':[
    '编译器对代码优化是建立在【代码中间表示】或者是【机器码】上的，不是直接在Java源码上的',
    {'方法内联':[
        {'目的':[
            '去除方法调用的成本（如查找方法版本、建立栈帧等）',
            '为其他优化建立良好的基础'
        ]},
        {'虚方法的内联问题':[
            'Java语言中默认的实例方法是【虚方法】:',
            'Java方法调用必须在运行时进行方法接收者的多态选择',
            '解决：类型继承关系分析技术',
            {'CHA':[
                '用于确定已加载的类中',
                '接口是否有多于一种的实现',
                '某个类是否存在子类',
                '子类是否覆盖了父类的某个虚方法'
            ]},
            '单态内联缓存:比用不内联的非虚方法调用,开销多了一次类型判断',
            '多态内联缓存:开销相当于真正查找虚方法表来进行方法分派'
        ]}
    ]},
    {'逃逸分析':[
        '分析对象动态作用域，对象在方法里面被定义后，可能被外部方法引用',
        {'对象逃逸程度':[
            '从不逃逸',
            '方法逃逸:作为调用参数传递到其他方法中',
            '线程逃逸:被外部线程访问到，如赋值给可在其他线程访问的实例变量'
        ]},
        {'栈上分配（Stack Allocations）':{
            '让对象在栈上分配内存，对象随着方法结束(栈帧出栈)而销毁',
            '降低垃圾收集器的压力',
            '支持方法逃逸，不支持线程逃逸'
        }},
        {'标量替换（Scalar Replacement）':[
            {'标量':[
                '无法再分解的数据',
                'Java中的对象是典型的聚合量,由多个标量组成'
            ]},
            '对象拆分,除其成员变量可在栈上分配和读写，还可为后续进一步的优化手段创建条件',
            '不允许对象逃逸出方法范围内'
        ]},
        '同步消除（Synchronization Elimination）'
    ]},
    {'公共子表达式消除':[
        '公共子表达式:表达式E之前已被计算过，先前的计算到现在E中所有变量的值都未发生变化'
    ]},
    {'数组边界检查消除':[
        '把运行期检查提前到编译期'
    ]},
    {'Java虚拟机编译器接口JVMCI':[
        '响应HotSpot的编译请求，并将请求分发给Java实现的即时编译器',
        '允许编译器访问HotSpot中与即时编译相关的数据结构',
        '包括类、字段、方法及其性能监控数据等，并提供这些数据结构在Java语言层面的抽象表示',
        '提供HotSpot代码缓存的Java端抽象表示，允许编译器部署编译完成的二进制机器码'
    ]},
    {'代码中间表示':[
        '编译器内部：字节码→理想图→优化→机器码',
        {'理想图':[
            '一种有向图，用节点来表示程序中的元素，如变量、操作符、方法、字段等，用边来表示数据或者控制流',
            '本质上将【数据流图】和【控制流图】以某种方式合并，用一种边来表示数据流向，另一种边表示控制流向的图形',
            {'理想图节点两个主操作':[
                '规范化:优化代码，缩减理想图的规模',
                '生成机器码:代码翻译'
            ]}
        ]},
        {'代码优化与生成':[

        ]}
    ]}],
'12.Java内存模型与线程':[
    {'CPU与内存':[
        {'矛盾':[
            '速度差距大，时间都花费在磁盘I/O、网络通信或者数据库访问上'
        ]},
        {'解决方案：高速缓存':[
            '作为内存与CPU间的缓冲',
            '读写速度接近CPU运算速度',
            {'缓存一致性协议':[
                '解决多CPU运算任务涉及一块主内存时',
                '导致各自的缓存数据不一致问题'
            ]}
        ]}
    ]},
    {'Java内存模型':[
        {'目的':[
            '定义程序中各种变量的访问规则'
        ]},
        {'重要概念':[
            '主内存:所有的变量都存储其上（类比物理硬件内存）',
            '工作内存：每条线程一份（类比CPU缓存），保存线程使用变量的主内存副本',
            '线程对变量的操作在工作内存进行，不直接读写主内存中数据'
        ]},
        {'内存间交互操作':[
            {'8种':[
                {'lock（锁定）':[
                    '作用于主内存变量',
                    '标识一条线程独占的状态'
                ]},
                {'unlock（解锁）':[
                    '作用于主内存变量',
                    '把一个处于锁定状态的变量释放出来'
                ]},
                {'read（读取）':[
                    '作用于主内存变量',
                    '把变量值从主内存传输到线程的工作内存，以便load动作使用'
                ]},
                {'load（载入）':[
                    '作用于工作内存变量',
                    '把read操作从主内存中得到的变量值放入工作内存中'
                ]},
                {'use（使用）':[
                    '作用于工作内存变量',
                    '把工作内存中的变量值传递给执行引擎',
                    '虚拟机遇到使用变量值的字节码指令时执行此操作'
                ]},
                {'assign（赋值）':[
                    '作用于工作内存变量',
                    '把从执行引擎接收的值赋给变量',
                    '虚拟机遇到给变量赋值的字节码指令时执行此操作'
                ]},
                {'store（存储）':[
                    '作用于工作内存变量',
                    '把工作内存中变量的值传送到主内存，以便write操作使用'
                ]},
                {'write（写入）':[
                    '作用于主内存变量',
                    '把store操作从工作内存中得到的变量值放入主内存的变量'
                ]}
            ]},
            {'规则限定':[
                '一个新的变量只能在主内存中诞生',
                '一个变量从主内存拷贝到工作内存，要按顺序执行read和load操作',
                '变量从工作内存同步回主内存，要按顺序执行store和write操作',
                '对一个变量执行unlock操作前，需要把变量同步回主内存中（执行store、write操作）'
            ]}
        ]},
        {'volatile修饰变量':[
            {'变量对所有线程可见':[
                '但并发不安全，因运算操作符并非原子操作，如果a++,由4条字节码指令构成',
                '一条字节码指令解释执行，解释器要运行许多行代码才能实现它的语义',
                '一条字节码指令编译执行，可能转化成若干条本地机器码指令'
            ]},
            {'禁止指令重排序优化':[
                'lock addl$0x0，(%esp)作用:相当于一个内存屏障（重排序时不能把后面的指令重排到内存屏障前)',
                'lock前缀:将本处理器的缓存写入了内存&&引起别的处理器或者别的内核无效化其缓存',
                '这样一个空操作，可让volatile变量的修改对其他处理器立即可见'
            ]}
        ]},
        {'原子性、可见性与有序性':[
            {'原子性':[
                'read、load、assign、use、store和write六个',
                '基本数据类型访问、读写都具备原子性',
                '更大范围原子性保证:lock和unlock'
            ]},
            {'可见性':[
                '实现可见性的关键字：synchronized，final和volatile',
                {'synchronized':[
                    '对变量执行unlock操作前，须先把此变量同步回主内存中'
                ]},
                {'final':[
                    '字段在构造器中一旦被初始化完成，其他线程中就能看见final字段的值'
                ]},
                {'volatile':[
                    '新值能立即同步到主内存，以及每次使用前立即从主内存刷新'
                ]}
            ]},
            {'有序性':[
                '在本线程内观察，所有操作都是有序的:线程内似表现为串行',
                '在A线程中观察B线程，所有操作都是无序的:指令重排序和工作内存与主内存同步延迟'
            ]}
        ]},
        {'先行发生规则':[
            '程序次序规则',
            '管程锁定和volatile变量规则',
            '线程启动,终止,中断，终结规则',
            '传递性规则',
            '时间顺序与先行发生原则无因果关系，衡量并发安全问题以先行发生原则为准'
        ]}
    ]},
    {'Java与线程':[
        {'线程':[
            'Java里进行处理器资源调度的最基本单位'
        ]},
        {'实现线程主要三种方式':[
            {'内核线程实现（1：1）':[
                {'内核线程':[
                    '直接由操作系统内核支持的线程',
                    '由内核来完成线程切换',
                    '操纵调度器对线程进行调度,将线程任务映射到各处理器上'
                ]},
                {'轻量级进程':[
                    '由一个内核线程支持',
                    {'局限性':[
                        '基于内核线程实现，各种线程操作如创建、析构及同步需系统调用',
                        '代价高，要在用户态，内核态中来回切换',
                        '消耗内核资源，系统支持进程的数量有限'
                    ]}
                ]}
            ]},
            {'用户线程实现（1：N）':[
                {'用户线程':[
                    '建立在用户空间的线程库上，系统内核感知不到其存在及实现'
                ]},
                {'优点':[
                    '线程操作如建立、同步、销毁完全在用户态中完成',
                    '不需内核帮助，不需切换内核态，操作快且低消耗，支持大线程数量'
                ]},
                {'缺点':[
                    '没有系统内核的支援',
                    '所有的线程操作都由用户程序自己处理'
                ]}
            ]},
            '使用用户线程加轻量级进程混合实现（N：M）'
        ]},
        {'Java线程':[
            '一个Java线程:直接映射到一个操作系统原生线程来实现的',
            {'线程调度':[
                {'协同式':[
                    '线程执行时间自己控制',
                    '自己工作执行完后，主动通知系统切换到另外一个线程'
                ]},
                {'抢占式':[
                    '每个线程由系统来分配执行时间',
                    '线程的切换不由线程本身来决定'
                ]}
            ]},
            {'状态转换':[
                '新建（New）：创建后尚未启动的线程',
                {'运行（Runnable）':[
                    '操作系统线程状态中的Running和Ready',
                    '线程可能正在执行，可能在等待操作系统为它分配执行时间'
                ]},
                '无限期等待（Waiting）：线程不会被分配处理器执行时间，要等待被其他线程显式唤醒',
                '限期等待（Timed Waiting）：线程不会被分配处理器执行时间，一定时间后由系统自动唤醒',
                '阻塞（Blocked）:线程等待一个排它锁',
                '结束（Terminated）：线程已经结束执行'
            ]}
        ]},
    ]},
    {'Java与协程':[
        {'协程':[
            '有栈协程,会完整地做调用栈的保护、恢复工作'
        ]},
        {'线程切换':[
            {'线程切换时的上下文数据':[
                '线程共享资源：物理硬件的各种存储设备和寄存器',
                '线程角度:方法的调用栈中存储的各类信息',
                '操作系统和硬件的角度:存储在内存、缓存和寄存器中的具体数值'
            ]},
            '1.中断发生，线程A切换到线程B之前，操作系统把线程A的上下文数据保管好',
            '2.把寄存器、内存分页等恢复到线程B挂起时候的状态',
        ]}
    ]}],
'13.线程安全与锁优化':[
    {'线程安全':[
        {'定义':[
            '多线程 同时 访问一个对象',
            '不用考虑线程在运行时环境下的调度和交替执行',
            '不需要进行额外的同步',
            '不需要调用方进行任何其他的协调操作',
            '调用对象的行为都可获得正确结果'
        ]},
        {'线程安全程度分类，5类':[
            {'不可变':[
                '一定是线程安全',
                '对象方法实现或方法的调用者，均不需进行任何线程安全保障措施',
                '基本数据类型：final修饰',
                '对象：其行为不会对其状态产生影响',
                '途径多种，如把对象里面带有状态的变量声明为final'
            ]},
            {'绝对线程安全':[
                'Java API中标注线程安全的类，大多都不是绝对线程安全',
                '如java.util.Vector'
            ]},
            {'相对线程安全':[
                '对对象单次操作是线程安全的，调用时不需额外保障措施',
                '对连续调用，调用端要使用额外同步手段',
                '如Vector、HashTable等'
            ]},
            {'线程兼容':[
                '对象本身并不是线程安全的，调用端可使用同步手段保证其并发安全',
                'ArrayList和HashMap'
            ]},
            {'线程对立':[
                '调用端是否采取措施，都无法在多线程环境中并发使用',
                'System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等'
            ]}
        ]},
        {'线程安全实现方法':[
            {'互斥同步':[
                {'同步':[
                    '多个线程并发访问，保证共享数据在同一时刻只被一条线程使用'
                ]},
                {'互斥':[
                    '实现同步的一种手段，如：临界区、互斥量和信号量'
                ]},
                {'synchronized':[
                    '块结构的同步语法',
                    {'Javac编译后指令':[
                        'monitorenter和monitorexit',
                        '出现在同步块前后',
                        '指令有一个reference类型的参数指明锁定和解锁对象'
                    ]},
                    {'执行过程':[
                        '执行monitorenter指令，尝试获取对象的锁',
                        '如对象没锁，或当前线程已持有对象锁，锁的计数器值+1',
                        '执行monitorexit指令时会锁计数器值-1',
                        '计数器的值为0，锁被释放',
                        '如获取对象锁失败，当前线程等待，直到锁定对象被释放'
                    ]},
                    {'重量级操作':[
                        'Java的线程：操作系统原生内核线程=1：1',
                        '阻塞或唤醒线程，需操作系统帮忙，用户态与核心态切换耗cpu时间'
                    ]},
                    {'优化':[
                        '通知操作系统阻塞线程前:加入一段自旋，避免频繁地切入核心态'
                    ]}
                ]},
                {'java.util.concurrent.locks.Lock':[
                    '重入锁（ReentrantLock）:Lock接口常见的一种实现',
                    '等待可中断、可实现公平锁及锁可以绑定多个条件'
                ]}
            ]},
            {'非阻塞同步':[
                {'基于冲突检测的乐观并发策略':[
                    '不需把线程阻塞挂起，直接操作',
                    '共享数据未被争用：操作直接成功',
                    '共享数据被争用：进行其他的补偿措施(不断重试)',
                    '操作和冲突检测两个步骤需要具备原子性'
                ]},
                {'处理器指令':[
                    '测试并设置（Test-and-Set）',
                    '获取并增加（Fetch-and-Increment）',
                    '交换（Swap）',
                    '比较并交换（Compare-and-Swap，CAS）',
                    '加载链接/条件储存'
                ]},
                {'CAS指令':[
                    {'三个操作数':[
                        '内存位置（变量的内存地址V）',
                        '旧的预期值A',
                        '准备设置的新值B'
                    ]},
                    {'执行指令':[
                        '当且仅当V符合A时',
                        '处理器才会用B更新V的值',
                        '否则不执行更新',
                        '不管是否更新V值，都返回V的旧值'
                    ]},
                    '原子操作，执行期间不会被其他线程中断',
                    'ABA问题'
                ]}
            ]},
            {'无同步方案':[
                '同步与线程安全没有必然联系',
                '方法不涉及共享数据,代码线程安全',
                {'可重入代码':[
                    '方法返回结果可预测，输入了相同的数据，都返回相同的结果'
                ]},
                {'线程本地存储':[
                    '代码中所需数据须与其他代码共享，试下共享数据的代码维护在一个线程',
                    '消费队列：消息消费过程限制在一个线程中',
                    'Web交互模型：一个请求对应一个服务器线程',
                    'java.lang.ThreadLocal类：实现线程本地存储功能'
                ]}
            ]}
        ]}
    ]},
    {'锁优化':[
        {'自旋锁':[
            '两个及以上cpu，能让多线程同时并行执行',
            '后请求锁的线程自旋,不放弃处理器的执行时间'
        ]},
        {'自适应自旋':[
            '自旋时间不固定',
            '由前一次同一个锁上的自旋时间及锁的拥有者的状态来决定的'
        ]},
        {'锁消除':[
            '代码中，堆上的数据不会逃逸出去被其他线程访问到',
            '可当作栈上数据对待，认为它们线程私有,不用加锁',
            '如：三个字符串相加,转化为StringBuilder对象的连续append()操作',
            '解释执行时加锁，经过编译器的即时编译后，代码会忽略同步措施'
        ]},
        {'锁粗化':[
            '一串零碎的操作都对同一个对象加锁，把加锁同步的范围扩展到外部'
        ]},
        {'轻量级锁':[
            {'加锁过程':[
                '1.代码将进入同步块，同步对象未被锁定（锁标志位01）',
                '在当前线程的栈帧中建立名为锁记录的空间,存储锁对象Mark Word的拷贝',
                '2.CAS操作把对象的Mark Word更新为指向Lock Record的指针',
                '3.更新成功：线程拥有对象的锁，对象Mark Word的锁标志位变为00（轻量级锁定状态）',
                '4.更新失败，检查对象Mark Word是否指向当前线程的栈帧',
                '是：当前线程已经拥有对象锁，直接进入同步块继续执行',
                '否：锁对象被其他线程抢占，轻量级锁膨胀为重量级锁，锁标志变为10，Mark Word指向互斥锁指针'
            ]},
            {'解锁过程':[
                '对象Mark Word指向线程的锁记录',
                'CAS操作把对象当前的Mark Word和线程中复制的Mark Word替换回来',
                '成功替换:同步过程就顺利完成',
                '替换失败:其他线程尝试过获取锁，要在释放锁的同时，唤醒被挂起线程'
            ]}
        ]},
        {'偏向锁':[
            {'目的':[
                '消除数据在无竞争情况下的同步，提高程序运行性能'
            ]},
            {'过程':[
                '锁对象第一次被线程获取时，把对象头中的标志位变为01、偏向模式变为1',
                'CAS操作把获取到锁的线程ID记录在对象Mark Word中',
                'CAS操作成功:持有偏向锁的线程以后进入锁相关的同步块，不再进行同步操作（如加锁、解锁，Mark Word的更新）'
            ]},
            {'失效':[
                '另外一个线程尝试获取锁，偏向模式马上结束',
                '根据锁对象目前是否处于被锁定的状态决定是否撤销偏向',
                '撤销后标志位恢复到未锁定01或轻量级锁定00',
                '后续的同步操作按照轻量级锁执行'
            ]},
            {'失败情况':[
                '对象计算过哈希码了，没位置存线程id'
            ]}
        ]},
        {'轻量级锁，偏向锁对比':[
            '轻量级锁:在无竞争的情况下,使用CAS操作去消除同步使用的互斥量',
            '偏向锁:在无竞争的情况下,把整个同步都消除掉',
        ]}
    ]}
]
}

#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 