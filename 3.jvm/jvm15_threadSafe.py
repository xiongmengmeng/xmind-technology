import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
xmind_name="jvm"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("jvm_threadSafe")
r2=s2.getRootTopic()
r2.setTitle("线程安全")


content={
'定义':[
    '多线程 同时 访问一个对象',
    '不用考虑线程在运行时环境下的调度和交替执行',
    '不需要进行额外的同步',
    '不需要调用方进行任何其他的协调操作',
    '调用对象的行为都可获得正确结果'
],
'程度分类(共5类)':[
    {'不可变':[
        '一定是线程安全',
        '对象方法实现或方法的调用者，均不需进行任何线程安全保障措施',
        '基本数据类型：final修饰',
        '对象：其行为不会对其状态产生影响',
        '途径多种，如把对象里面带有状态的变量声明为final'
    ]},
    {'绝对线程安全':[
        'Java API中标注线程安全的类，大多都不是绝对线程安全',
        '如java.util.Vector'
    ]},
    {'相对线程安全':[
        '对对象单次操作是线程安全的，调用时不需额外保障措施',
        '对连续调用，调用端要使用额外同步手段',
        '如Vector、HashTable等'
    ]},
    {'线程兼容':[
        '对象本身并不是线程安全的，调用端可使用同步手段保证其并发安全',
        'ArrayList和HashMap'
    ]},
    {'线程对立':[
        '调用端是否采取措施，都无法在多线程环境中并发使用',
        'System.setIn()、Sytem.setOut()和System.runFinalizersOnExit()等'
    ]}
],
'互斥同步':[
    {'同步':[
        '多个线程并发访问，保证共享数据在同一时刻只被一条线程使用'
    ]},
    {'互斥':[
        '实现同步的一种手段，如：临界区、互斥量和信号量'
    ]},
    {'synchronized':[
        '块结构的同步语法',
        {'Javac编译后指令':[
            'monitorenter和monitorexit',
            '出现在同步块前后',
            '指令有一个reference类型的参数指明锁定和解锁对象'
        ]},
        {'执行过程':[
            '执行monitorenter指令，尝试获取对象的锁',
            '如对象没锁，或当前线程已持有对象锁，锁的计数器值+1',
            '执行monitorexit指令时,锁计数器值-1',
            '计数器的值为0，锁被释放',
            '如获取对象锁失败，当前线程等待，直到锁定对象被释放'
        ]},
        {'重量级操作':[
            'Java的线程：操作系统原生内核线程=1：1',
            '阻塞或唤醒线程，需操作系统帮忙，用户态与核心态切换耗cpu时间'
        ]},
        {'优化':[
            '通知操作系统阻塞线程前:加入一段自旋，避免频繁地切入核心态'
        ]}
    ]},
    {'java.util.concurrent.locks.Lock':[
        '重入锁（ReentrantLock）:Lock接口常见的一种实现',
        '等待可中断、可实现公平锁及锁可以绑定多个条件',
        'RedissonLock:分布式锁'
    ]}
],
'非阻塞同步':[
    {'基于冲突检测的乐观并发策略':[
        '不需把线程阻塞挂起，直接操作',
        '共享数据未被争用：操作直接成功',
        '共享数据被争用：进行其他的补偿措施(不断重试)',
        '操作和冲突检测两个步骤需要具备原子性'
    ]},
    {'处理器指令':[
        '测试并设置（Test-and-Set）',
        '获取并增加（Fetch-and-Increment）',
        '交换（Swap）',
        '比较并交换（Compare-and-Swap，CAS）',
        '加载链接/条件储存'
    ]},
    {'CAS指令':[
        {'三个操作数':[
            '内存位置（变量的内存地址V）',
            '旧的预期值A',
            '准备设置的新值B'
        ]},
        {'执行指令':[
            '当且仅当V符合A时',
            '处理器才会用B更新V的值',
            '否则不执行更新',
            '不管是否更新V值，都返回V的旧值'
        ]},
        '原子操作，执行期间不会被其他线程中断',
        'ABA问题'
    ]}
],
'无同步方案':[
    '同步与线程安全没有必然联系',
    '方法不涉及共享数据,代码线程安全',
    {'可重入代码':[
        '方法返回结果可预测，输入了相同的数据，都返回相同的结果'
    ]},
    {'线程本地存储':[
        '代码中所需数据须与其他代码共享，试下共享数据的代码维护在一个线程',
        '消费队列：消息消费过程限制在一个线程中',
        'Web交互模型：一个请求对应一个服务器线程',
        'java.lang.ThreadLocal类：实现线程本地存储功能'
    ]}
],
'线程安全实现方法':[
    '互斥同步',
    '非阻塞同步',
    '无同步方案'
]



}

#构建xmind
xmind.build(content,r2)

#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 