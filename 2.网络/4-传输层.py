import os,sys 
parentdir = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 
sys.path.insert(0,parentdir) 

import xmind
from xmind.core.markerref import MarkerId
xmind_name="internet"
w = xmind.load(os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 
s2=w.createSheet()
s2.setTitle("传输层")
r2=s2.getRootTopic()
r2.setTitle("传输层")


content={
'作用':[
    '定义端口，标识应用程序身份，实现端口到端口的通信'
],
'使用协议':[
    'UDP协议',
    'TCP协议(TCP就是有确认机制的UDP协议):三次握手+ACK确认'
],
'TCP/UDP数据包':[
    '首部8个字节，主要包括源端口和目标端口',
    '数据:UDP最大为65527个字节,TCP不限,但不会超过IP数据包的长度,防止分割'
],
'ACK':[
    {'ACK号等待时间':[
        '据网络包平均往返时间调整ACK号等待时间'
    ]},
    {'方式':[
        '一来一回方式',
        {'滑动窗口方式':[
            '接收方需要告诉发送方自己最多能接收多少数据(接收缓冲区剩余空间)',
            '发送方根据这个值对数据发送操作进行控制',
            'ACK与窗口的合并,减少网络开销'
        ]}
    ]},
    '通过“序号”和“ACK号”确认接收方是否收到了网络包',
],
'用UDP协议收发数据':[
    '适用：不需要重发的数据',
    {'发送':[
        '没有TCP的接收确认、窗口等机制',
        '收发数据前不需要交换控制信息(不需要建立和断开连接)'
    ]},
    {'接收':[
        '根据IP头部中接收方和发送方IP地址',
        'UDP头部中的接收方和发送方端口号',
        '找到相应的套接字将数据交给相应的应用程序'
    ]},
    '应用：音频和视频数据,缺少某些包不会产生严重问题，只会有一些失真或者卡顿'
],
'自动重传请求（Auto Repeat reQuest，ARQ）':[
    '通过接收方请求发送方重传出错的数据帧来恢复出错的帧，是通信中用于处理信道所带来差错的方法之一',
    {'传统自动重传请求分为三种':[
        '即停等式（Stop-and-Wait）',
        '后退N帧（Go-Back-N）ARQ',
        '选择性重传（Selective Repeat）ARQ'
    ]},
    '后两种协议是滑动窗口技术与请求重发技术的结合，由于窗口尺寸开到足够大，帧在线路上可以连续地流动，因此又称为连续ARQ协议',
    {'1.停等协议':[
        '发送方发完一帧后，停止发送，并启动定时器，等待对方应答',
        '接收方收到帧，若正确则一应答ACK，错误则应答NAK',
        '发送者若收到ACK，接着发送下一帧',
        '若收到NAK，或超时，则重发下一帧'
    ]},
    {'停等ARQ':[
        '将差错控制和流量控制结合起来，接收方对帧校验，出错则重发',
        {'措施':[
            '发送方和接收方各有一个帧缓冲区',
            '为解决重复帧问题，需要对帧进行编号，编号只需要两个(0和1)，以区分是新的帧还是重复之前的帧，',
            '发送帧依次交替编号 为0，1帧',
            '应答帧则需要指明所应答的帧号',
            '设置超时重发'
        ]}
    ]},
    {'3.滑动窗囗协议':[
        '发送方和接收方都有一事实上容量的缓冲区（窗口），允许发送丫连续发送多个帧而不需要等待应答'
    ]},
    {'4.窗口机制':[
        {'发送窗囗':[
            '发送端允许连续发送的帧的序号表，发送端可以不等待应答而连续发送的最大帧数称为发送窗口的尺寸'
        ]},
        {'接收窗口':[
            '接收端允许接收的帧的序号表，凡落在接收窗口内的帧，接收方都必须处理，落在接收窗口外的帧被丢弃，接收方每次允许接收的帧数称为接收窗口的尺寸'
        ]},
        
    ]},
    {'5.滑动窗囗':[
        {'目的':[
            '对可以连续发出的最大帧数（已发出未确认的帧）做限制',
            ''
        ]},
        {'序号使用':[
            '循环重复使用有限的帧序号'
        ]},
        {'流量控制':[
            '发送窗口：其大小Wt表示在收到对方确认的信息之前，可以连续发出的最多数据帧数（只有序号在窗口内的帧才可以发送）',
            '接收窗口：其大小Wr表示可以连接接收的最多数据帧数（只有序号在窗口内的帧才可以接收，否则丢弃）',
            '接收窗口驱动发送窗口的移动'
        ]}
    ]},
    {'6.连续ARQ':[
        {'发送方':[
            '连续发出多帧后，因还未收到对方确认信息，发送窗口缩小，当收到对方确认回答后，清除已确认的帧所占的帧缓冲区，因而发送窗口扩大'
        ]},
        {'接收方':[
            '若接收帧后尚未回答，因帧数数据还未交上层，其帧缓冲未释放，接收窗口缩小',
            '若接收端回答后，表未帧数据已经上交上层，接收缓冲区空出，因此接收窗口相遇扩大'
        ]},
        {'应答策略':[
            '1.接收发在收到一个帧后可以等待一定的时间后再应答，不必对每一个帧都单独应答，通常用对某一个帧的应答来代替对该帧之前的所有帧的应答',
            '2.收到ACK n应答帧后，表示n号之前的数据帧已经被正确接收，希望下次接收n号帧',
            '例如ACK 5，代表1，2，3，4，5都已经正确接收了',
            '3.收到NAK n应答帧后，表示n号之前的数据帧已经被正确接收，而 n号帧出错，希望重发n号帧',
            '例如NAK 5，代表1，2，3，4，5都已经正确接收了，而5接收失败了',
            '4.发送方发出一帧后，启用相映的定时器，超时会重发'

        ]}
    ]},
    {'7.出错重发':[
        '出错选择重发，出错全部重发'
    ]}
]
}


#构建xmind
xmind.build(content,r2)
#保存xmind
xmind.save(w,os.path.dirname(os.path.abspath(__file__))+"\\"+xmind_name+".xmind") 